/**
 * @fileOverview Generated by @croc/generator-webclient:client-classes Yeoman-generator, v1.39.0.
 */
import lang = require("lib/core.lang");
import support = require("lib/domain/support");
import _DomainObject = require("lib/domain/DomainObject");
import _UnitOfWork = require("lib/domain/UnitOfWork");
import ComplexValue = require("lib/domain/ComplexValue");
import Big = require("big");
import LobPropValue = support.LobPropValue;

import { metadata, IDomainCollection, INavigationPropSet } from "lib/domain/.domain";
import { IDataFacade } from "lib/interop/.interop";

export const factory: any;

export class UnitOfWork extends _UnitOfWork {
	constructor(dataFacade: IDataFacade, options: _UnitOfWork.Options);
	createPersonCorrespondent(props?: lang.Map<any>): PersonCorrespondent;
	createCommissionJournalFilter(props?: lang.Map<any>): CommissionJournalFilter;
	createContractRevokeReason(props?: lang.Map<any>): ContractRevokeReason;
	createInboxFilter(props?: lang.Map<any>): InboxFilter;
	createEmployee(props?: lang.Map<any>): Employee;
	createDeliveryOption(props?: lang.Map<any>): DeliveryOption;
	createRendition(props?: lang.Map<any>): Rendition;
	createIncomingDocumentAddressee(props?: lang.Map<any>): IncomingDocumentAddressee;
	createSearchResultDocumentWithAttachments(props?: lang.Map<any>): SearchResultDocumentWithAttachments;
	createCurrencyFilter(props?: lang.Map<any>): CurrencyFilter;
	createDocumentSubType(props?: lang.Map<any>): DocumentSubType;
	createDashboard(props?: lang.Map<any>): Dashboard;
	createCreateDocumentProcessParams(props?: lang.Map<any>): CreateDocumentProcessParams;
	createAbstractCorrespondent(props?: lang.Map<any>): AbstractCorrespondent;
	createDocumentTypeTreeFilter(props?: lang.Map<any>): DocumentTypeTreeFilter;
	createOrgStructureRootElement(props?: lang.Map<any>): OrgStructureRootElement;
	createInboxViewItem(props?: lang.Map<any>): InboxViewItem;
	createAbstractCorrespondentContact(props?: lang.Map<any>): AbstractCorrespondentContact;
	createContractorCreationParams(props?: lang.Map<any>): ContractorCreationParams;
	createOutgoingDocumentAddressee(props?: lang.Map<any>): OutgoingDocumentAddressee;
	createApprover(props?: lang.Map<any>): Approver;
	createApprovalIteration(props?: lang.Map<any>): ApprovalIteration;
	createCompanyPersonCorrespondent(props?: lang.Map<any>): CompanyPersonCorrespondent;
	createAssistant(props?: lang.Map<any>): Assistant;
	createContractRevokeReasonFilter(props?: lang.Map<any>): ContractRevokeReasonFilter;
	createCurrency(props?: lang.Map<any>): Currency;
	createAbstractDocumentRelation(props?: lang.Map<any>): AbstractDocumentRelation;
	createComment(props?: lang.Map<any>): Comment;
	createDisciplineReportParams(props?: lang.Map<any>): DisciplineReportParams;
	createCommissionPerformerStatus(props?: lang.Map<any>): CommissionPerformerStatus;
	createCompany(props?: lang.Map<any>): Company;
	createPositionDescription(props?: lang.Map<any>): PositionDescription;
	createDocumentAttachment(props?: lang.Map<any>): DocumentAttachment;
	createCommissionPerformerReportStatus(props?: lang.Map<any>): CommissionPerformerReportStatus;
	createContractDocumentContractor(props?: lang.Map<any>): ContractDocumentContractor;
	createDocumentProcessTypeFakeModel(props?: lang.Map<any>): DocumentProcessTypeFakeModel;
	createOutgoingDocumentJournalFilter(props?: lang.Map<any>): OutgoingDocumentJournalFilter;
	createAbstractDocument(props?: lang.Map<any>): AbstractDocument;
	createLockInfoDefault(props?: lang.Map<any>): LockInfoDefault;
	createTempContent(props?: lang.Map<any>): TempContent;
	createCommissionPerformer(props?: lang.Map<any>): CommissionPerformer;
	createWeekBasedWorkingCalendarDateInterval(props?: lang.Map<any>): WeekBasedWorkingCalendarDateInterval;
	createCorrespondentAddress(props?: lang.Map<any>): CorrespondentAddress;
	createCommission(props?: lang.Map<any>): Commission;
	createBookmark(props?: lang.Map<any>): Bookmark;
	createApprovalDecision(props?: lang.Map<any>): ApprovalDecision;
	createAbstractOrgStructureElement(props?: lang.Map<any>): AbstractOrgStructureElement;
	createCorrespondentContactDefault(props?: lang.Map<any>): CorrespondentContactDefault;
	createSmartSearchFilter(props?: lang.Map<any>): SmartSearchFilter;
	createWeekBasedWorkingCalendar(props?: lang.Map<any>): WeekBasedWorkingCalendar;
	createReport(props?: lang.Map<any>): Report;
	createReportContent(props?: lang.Map<any>): ReportContent;
	createContractor(props?: lang.Map<any>): Contractor;
	createCommonTaskCommand(props?: lang.Map<any>): CommonTaskCommand;
	createTaskType(props?: lang.Map<any>): TaskType;
	createDocumentKind(props?: lang.Map<any>): DocumentKind;
	createAccessorsGroupItem(props?: lang.Map<any>): AccessorsGroupItem;
	createRegNumberTemplate(props?: lang.Map<any>): RegNumberTemplate;
	createDocumentToDocumentRelation(props?: lang.Map<any>): DocumentToDocumentRelation;
	createAttachment(props?: lang.Map<any>): Attachment;
	createReportGenerationTask(props?: lang.Map<any>): ReportGenerationTask;
	createRegisterDocumentProcessParams(props?: lang.Map<any>): RegisterDocumentProcessParams;
	createRoleParamDescriptorDefault(props?: lang.Map<any>): RoleParamDescriptorDefault;
	createIncomingDocument(props?: lang.Map<any>): IncomingDocument;
	createEmployeePosition(props?: lang.Map<any>): EmployeePosition;
	createPosition(props?: lang.Map<any>): Position;
	createWarrantDocument(props?: lang.Map<any>): WarrantDocument;
	createRoleDescriptorDefault(props?: lang.Map<any>): RoleDescriptorDefault;
	createRelationType(props?: lang.Map<any>): RelationType;
	createCorrespondentFilter(props?: lang.Map<any>): CorrespondentFilter;
	createCompanyCorrespondent(props?: lang.Map<any>): CompanyCorrespondent;
	createContractDocument(props?: lang.Map<any>): ContractDocument;
	createDepartment(props?: lang.Map<any>): Department;
	createWeekBasedWorkingCalendarDayInterval(props?: lang.Map<any>): WeekBasedWorkingCalendarDayInterval;
	createUser(props?: lang.Map<any>): User;
	createContractorFilter(props?: lang.Map<any>): ContractorFilter;
	createCommissionPerformerReportAttachment(props?: lang.Map<any>): CommissionPerformerReportAttachment;
	createAbstractReportParams(props?: lang.Map<any>): AbstractReportParams;
	createCommissionStatus(props?: lang.Map<any>): CommissionStatus;
	createCmisContent(props?: lang.Map<any>): CmisContent;
	createLockInfoCommand(props?: lang.Map<any>): LockInfoCommand;
	createNomenclatureCase(props?: lang.Map<any>): NomenclatureCase;
	createDocumentType(props?: lang.Map<any>): DocumentType;
	createContractDocumentJournalFilter(props?: lang.Map<any>): ContractDocumentJournalFilter;
	createCorrespondentContactType(props?: lang.Map<any>): CorrespondentContactType;
	createWarrantJournalFilter(props?: lang.Map<any>): WarrantJournalFilter;
	createCommissionPerformerReport(props?: lang.Map<any>): CommissionPerformerReport;
	createDocumentStatus(props?: lang.Map<any>): DocumentStatus;
	createApprovalQueue(props?: lang.Map<any>): ApprovalQueue;
	createCorrespondentContactKind(props?: lang.Map<any>): CorrespondentContactKind;
	createAccessorsGroup(props?: lang.Map<any>): AccessorsGroup;
	createDocumentTemplate(props?: lang.Map<any>): DocumentTemplate;
	createRelationTypeFilter(props?: lang.Map<any>): RelationTypeFilter;
	createNomenclatureYear(props?: lang.Map<any>): NomenclatureYear;
	createWorkingCalendarDayIntervalObject(props?: lang.Map<any>): WorkingCalendarDayIntervalObject;
	createIncomingDocumentJournalFilter(props?: lang.Map<any>): IncomingDocumentJournalFilter;
	createOutgoingDocument(props?: lang.Map<any>): OutgoingDocument;
	createDeliveryType(props?: lang.Map<any>): DeliveryType;
	createFiledIn(props?: lang.Map<any>): FiledIn;
	createUserFilter(props?: lang.Map<any>): UserFilter;
	createEmployeeFilter(props?: lang.Map<any>): EmployeeFilter;
	createPositionDescriptionFilter(props?: lang.Map<any>): PositionDescriptionFilter;
	createOrgStructureFilter(props?: lang.Map<any>): OrgStructureFilter;
	createFakeEmptyType(props?: lang.Map<any>): FakeEmptyType;
	createWeekBasedWorkingCalendarFilter(props?: lang.Map<any>): WeekBasedWorkingCalendarFilter;
	createCopyWeekBasedWorkingCalendarDateIntervalParams(props?: lang.Map<any>): CopyWeekBasedWorkingCalendarDateIntervalParams;
	createMainPageInboxFilter(props?: lang.Map<any>): MainPageInboxFilter;
	createApprovalIterationFilter(props?: lang.Map<any>): ApprovalIterationFilter;
	createNomenclatureTreeFilterModel(props?: lang.Map<any>): NomenclatureTreeFilterModel;

}

export class DomainObject extends _DomainObject {
	uow: UnitOfWork;
}


export interface DocumentPermissionMeta extends metadata.EnumMeta {
	members: {
		"COMMON": metadata.EnumMember;
		"DSP": metadata.EnumMember;
		"KT": metadata.EnumMember;
	};
}

export enum DocumentPermission {
	COMMON = 0,
	DSP = 1,
	KT = 2,
}
export namespace DocumentPermission {
	export const meta: DocumentPermissionMeta;
}

export interface ContractStateMeta extends metadata.EnumMeta {
	members: {
		"CS_PERFORMING": metadata.EnumMember;
		"CS_PERFORMED": metadata.EnumMember;
		"CS_NOT_PERFORMING": metadata.EnumMember;
		"CS_NOT_INTO_FORCE": metadata.EnumMember;
		"CS_DISSOLVED": metadata.EnumMember;
	};
}

export enum ContractState {
	CS_PERFORMING = 0,
	CS_PERFORMED = 1,
	CS_NOT_PERFORMING = 2,
	CS_NOT_INTO_FORCE = 3,
	CS_DISSOLVED = 4,
}
export namespace ContractState {
	export const meta: ContractStateMeta;
}

export interface ContractConditionIntoForceMeta extends metadata.EnumMeta {
	members: {
		"CCIF_IN_SIGNING_TIME": metadata.EnumMember;
		"CCIF_WITH_CONDITION": metadata.EnumMember;
	};
}

export enum ContractConditionIntoForce {
	CCIF_IN_SIGNING_TIME = 0,
	CCIF_WITH_CONDITION = 1,
}
export namespace ContractConditionIntoForce {
	export const meta: ContractConditionIntoForceMeta;
}

export interface BookmarkTypeMeta extends metadata.EnumMeta {
	members: {
		"ENTITY": metadata.EnumMember;
		"PART": metadata.EnumMember;
		"COMMAND": metadata.EnumMember;
	};
}

export enum BookmarkType {
	ENTITY = 0,
	PART = 1,
	COMMAND = 2,
}
export namespace BookmarkType {
	export const meta: BookmarkTypeMeta;
}

export interface ContractSettlementTypeMeta extends metadata.EnumMeta {
	members: {
		"CST_PROFITABLE": metadata.EnumMember;
		"CST_CONSUMABLES": metadata.EnumMember;
	};
}

export enum ContractSettlementType {
	CST_PROFITABLE = 0,
	CST_CONSUMABLES = 1,
}
export namespace ContractSettlementType {
	export const meta: ContractSettlementTypeMeta;
}

export interface ApprovalIterationStateMeta extends metadata.EnumMeta {
	members: {
		"PLANNED": metadata.EnumMember;
		"ACTIVE": metadata.EnumMember;
		"PROCESSED": metadata.EnumMember;
	};
}

export enum ApprovalIterationState {
	PLANNED = 0,
	ACTIVE = 1,
	PROCESSED = 2,
}
export namespace ApprovalIterationState {
	export const meta: ApprovalIterationStateMeta;
}

export interface ApprovalPlanningStageMeta extends metadata.EnumMeta {
	members: {
		"DEVELOPMENT": metadata.EnumMember;
		"TEMPLATE": metadata.EnumMember;
		"INSTANCE": metadata.EnumMember;
	};
}

export enum ApprovalPlanningStage {
	DEVELOPMENT = 0,
	TEMPLATE = 1,
	INSTANCE = 2,
}
export namespace ApprovalPlanningStage {
	export const meta: ApprovalPlanningStageMeta;
}

export interface DocumentProcessTypeMeta extends metadata.EnumMeta {
	members: {
		"DPT_CREATION": metadata.EnumMember;
		"DPT_REGISTRATION": metadata.EnumMember;
	};
}

export enum DocumentProcessType {
	DPT_CREATION = 1,
	DPT_REGISTRATION = 2,
}
export namespace DocumentProcessType {
	export const meta: DocumentProcessTypeMeta;
}

export interface NomenclatureStatusMeta extends metadata.EnumMeta {
	members: {
		"NS_CREATED": metadata.EnumMember;
		"NS_ACTIVE": metadata.EnumMember;
		"NS_CLOSED": metadata.EnumMember;
		"NS_DELETED": metadata.EnumMember;
	};
}

export enum NomenclatureStatus {
	NS_CREATED = 1,
	NS_ACTIVE = 2,
	NS_CLOSED = 3,
	NS_DELETED = 0,
}
export namespace NomenclatureStatus {
	export const meta: NomenclatureStatusMeta;
}

export interface ApprovalQueueTypeMeta extends metadata.EnumMeta {
	members: {
		"APPROVE": metadata.EnumMember;
		"SIGN": metadata.EnumMember;
		"APPROVE_ADDITIONAL": metadata.EnumMember;
	};
}

export enum ApprovalQueueType {
	APPROVE = 0,
	SIGN = 1,
	APPROVE_ADDITIONAL = 2,
}
export namespace ApprovalQueueType {
	export const meta: ApprovalQueueTypeMeta;
}

export interface IncomingDocumentAddresseeStatusMeta extends metadata.EnumMeta {
	members: {
		"IDAS_NEW": metadata.EnumMember;
		"IDAS_ON_REVIEW": metadata.EnumMember;
		"IDAS_REVIWED": metadata.EnumMember;
	};
}

export enum IncomingDocumentAddresseeStatus {
	IDAS_NEW = 0,
	IDAS_ON_REVIEW = 1,
	IDAS_REVIWED = 2,
}
export namespace IncomingDocumentAddresseeStatus {
	export const meta: IncomingDocumentAddresseeStatusMeta;
}

export interface OutgoingDocumentDeliveryStatusMeta extends metadata.EnumMeta {
	members: {
		"EMPTY": metadata.EnumMember;
		"SENDING": metadata.EnumMember;
		"SENT": metadata.EnumMember;
		"RETURNED": metadata.EnumMember;
	};
}

export enum OutgoingDocumentDeliveryStatus {
	EMPTY = 0,
	SENDING = 1,
	SENT = 2,
	RETURNED = 4,
}
export namespace OutgoingDocumentDeliveryStatus {
	export const meta: OutgoingDocumentDeliveryStatusMeta;
}

export interface SearchTypeMeta extends metadata.EnumMeta {
	members: {
		"CONTENT": metadata.EnumMember;
		"ATTRIBUTES": metadata.EnumMember;
	};
}

export enum SearchType {
	CONTENT = 1,
	ATTRIBUTES = 2,
}
export namespace SearchType {
	export const meta: SearchTypeMeta;
}

export interface CommissionTypeMeta extends metadata.EnumMeta {
	members: {
		"CT_TO_EXECUTE": metadata.EnumMember;
		"CT_TO_FAMILIARIZE": metadata.EnumMember;
	};
}

export enum CommissionType {
	CT_TO_EXECUTE = 1,
	CT_TO_FAMILIARIZE = 2,
}
export namespace CommissionType {
	export const meta: CommissionTypeMeta;
}

export interface ApprovalEntityStateMeta extends metadata.EnumMeta {
	members: {
		"PLANNED": metadata.EnumMember;
		"ACTIVE": metadata.EnumMember;
		"PROCESSED": metadata.EnumMember;
	};
}

export enum ApprovalEntityState {
	PLANNED = 0,
	ACTIVE = 1,
	PROCESSED = 2,
}
export namespace ApprovalEntityState {
	export const meta: ApprovalEntityStateMeta;
}

export interface ApprovalDecisionTypeMeta extends metadata.EnumMeta {
	members: {
		"WAIT": metadata.EnumMember;
		"REVOKED": metadata.EnumMember;
		"REJECTED": metadata.EnumMember;
		"APPROVED": metadata.EnumMember;
		"SIGNED": metadata.EnumMember;
	};
}

export enum ApprovalDecisionType {
	WAIT = 0,
	REVOKED = 1,
	REJECTED = 4,
	APPROVED = 8,
	SIGNED = 16,
}
export namespace ApprovalDecisionType {
	export const meta: ApprovalDecisionTypeMeta;
}

export interface ReportGenerationStatusMeta extends metadata.EnumMeta {
	members: {
		"RGS_NOT_STARTED": metadata.EnumMember;
		"RGS_PROCESSING": metadata.EnumMember;
		"RGS_READY": metadata.EnumMember;
		"RGS_ERROR": metadata.EnumMember;
	};
}

export enum ReportGenerationStatus {
	RGS_NOT_STARTED = 1,
	RGS_PROCESSING = 2,
	RGS_READY = 3,
	RGS_ERROR = 4,
}
export namespace ReportGenerationStatus {
	export const meta: ReportGenerationStatusMeta;
}

export interface NomenclatureCaseRetentionPolicyMeta extends metadata.EnumMeta {
	members: {
		"NCRP_PERMANENT": metadata.EnumMember;
		"NCRP_TEMPORARY": metadata.EnumMember;
	};
}

export enum NomenclatureCaseRetentionPolicy {
	NCRP_PERMANENT = 1,
	NCRP_TEMPORARY = 2,
}
export namespace NomenclatureCaseRetentionPolicy {
	export const meta: NomenclatureCaseRetentionPolicyMeta;
}

export interface WeekBasedWorkingCalendarIntervalTypeNamesMeta extends metadata.EnumMeta {
	members: {
		"HOLIDAY": metadata.EnumMember;
		"HALF_HOLIDAY": metadata.EnumMember;
	};
}

export type WeekBasedWorkingCalendarIntervalTypeNames = "HOLIDAY" | "HALF_HOLIDAY";
export declare const WeekBasedWorkingCalendarIntervalTypeNames: {
	meta: WeekBasedWorkingCalendarIntervalTypeNamesMeta;
	HOLIDAY: WeekBasedWorkingCalendarIntervalTypeNames;
	HALF_HOLIDAY: WeekBasedWorkingCalendarIntervalTypeNames;
};

export interface WeekBasedWorkingTimeDayNamesMeta extends metadata.EnumMeta {
	members: {
		"1": metadata.EnumMember;
		"2": metadata.EnumMember;
		"3": metadata.EnumMember;
		"4": metadata.EnumMember;
		"5": metadata.EnumMember;
		"6": metadata.EnumMember;
		"7": metadata.EnumMember;
	};
}

export type WeekBasedWorkingTimeDayNames = "1" | "2" | "3" | "4" | "5" | "6" | "7";
export declare const WeekBasedWorkingTimeDayNames: {
	meta: WeekBasedWorkingTimeDayNamesMeta;
	1: WeekBasedWorkingTimeDayNames;
	2: WeekBasedWorkingTimeDayNames;
	3: WeekBasedWorkingTimeDayNames;
	4: WeekBasedWorkingTimeDayNames;
	5: WeekBasedWorkingTimeDayNames;
	6: WeekBasedWorkingTimeDayNames;
	7: WeekBasedWorkingTimeDayNames;
};

export interface MainPageInboxFilterTaskNamesMeta extends metadata.EnumMeta {
	members: {
		"APPROVE": metadata.EnumMember;
		"SIGN": metadata.EnumMember;
		"REVIEW": metadata.EnumMember;
		"EXECUTION": metadata.EnumMember;
		"FAMILIARIZATION": metadata.EnumMember;
		"CHECKING": metadata.EnumMember;
	};
}

export type MainPageInboxFilterTaskNames = "APPROVE" | "SIGN" | "REVIEW" | "EXECUTION" | "FAMILIARIZATION" | "CHECKING";
export declare const MainPageInboxFilterTaskNames: {
	meta: MainPageInboxFilterTaskNamesMeta;
	APPROVE: MainPageInboxFilterTaskNames;
	SIGN: MainPageInboxFilterTaskNames;
	REVIEW: MainPageInboxFilterTaskNames;
	EXECUTION: MainPageInboxFilterTaskNames;
	FAMILIARIZATION: MainPageInboxFilterTaskNames;
	CHECKING: MainPageInboxFilterTaskNames;
};

export interface PersonCorrespondentMeta extends metadata.EntityMeta {
	props: AbstractCorrespondentMeta["props"] & {
		"firstName": metadata.PropertyMeta;
		"secondName": metadata.PropertyMeta;
		"patronymic": metadata.PropertyMeta;
		"name": metadata.PropertyMeta;
	};
	complex: AbstractCorrespondentMeta["complex"] ;
}
export type PersonCorrespondentNames = {
	readonly [P in keyof PersonCorrespondentMeta["props"] | keyof PersonCorrespondentMeta["complex"]]: string;
};

export class PersonCorrespondent extends AbstractCorrespondent {
	static meta: PersonCorrespondentMeta;
	static NAMES: PersonCorrespondentNames;
	meta: PersonCorrespondentMeta;
	init(): void;
	"firstName": lang.ObservableProperty<string>;
	"secondName": lang.ObservableProperty<string>;
	"patronymic": lang.ObservableProperty<string>;
	"name": lang.ObservableProperty<string>;
}

export interface CommissionJournalFilterMeta extends metadata.EntityMeta {
	props: {
		"documentRegNumber": metadata.PropertyMeta;
		"documentIdentifier": metadata.PropertyMeta;
		"commissionNumber": metadata.PropertyMeta;
		"documentSummary": metadata.PropertyMeta;
		"description": metadata.PropertyMeta;
		"status": metadata.PropertyMeta;
		"commissionType": metadata.PropertyMeta;
		"sentFrom": metadata.PropertyMeta;
		"sentTo": metadata.PropertyMeta;
		"deadlineFrom": metadata.PropertyMeta;
		"deadlineTo": metadata.PropertyMeta;
		"performer": metadata.PropertyMeta;
		"author": metadata.PropertyMeta;
		"overseer": metadata.PropertyMeta;
	};
}
export type CommissionJournalFilterNames = {
	readonly [P in keyof CommissionJournalFilterMeta["props"] | keyof CommissionJournalFilterMeta["complex"]]: string;
};

export class CommissionJournalFilter extends DomainObject {
	static meta: CommissionJournalFilterMeta;
	static NAMES: CommissionJournalFilterNames;
	meta: CommissionJournalFilterMeta;
	init(): void;
	"documentRegNumber": lang.ObservableProperty<string>;
	"documentIdentifier": lang.ObservableProperty<string>;
	"commissionNumber": lang.ObservableProperty<string>;
	"documentSummary": lang.ObservableProperty<string>;
	"description": lang.ObservableProperty<string>;
	"status": lang.ObservableProperty<CommissionStatus>;
	"commissionType": lang.ObservableProperty<CommissionType>;
	"sentFrom": lang.ObservableProperty<Date>;
	"sentTo": lang.ObservableProperty<Date>;
	"deadlineFrom": lang.ObservableProperty<Date>;
	"deadlineTo": lang.ObservableProperty<Date>;
	"performer": lang.ObservableProperty<EmployeePosition>;
	"author": lang.ObservableProperty<EmployeePosition>;
	"overseer": lang.ObservableProperty<EmployeePosition>;
}

export interface ContractRevokeReasonMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type ContractRevokeReasonNames = {
	readonly [P in keyof ContractRevokeReasonMeta["props"] | keyof ContractRevokeReasonMeta["complex"]]: string;
};

export class ContractRevokeReason extends DomainObject {
	static meta: ContractRevokeReasonMeta;
	static NAMES: ContractRevokeReasonNames;
	meta: ContractRevokeReasonMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"deleted": lang.ObservableProperty<boolean>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface InboxFilterMeta extends metadata.EntityMeta {
	props: {
		"taskId": metadata.PropertyMeta;
		"taskType": metadata.PropertyMeta;
		"documentType": metadata.PropertyMeta;
		"regNumber": metadata.PropertyMeta;
		"identifier": metadata.PropertyMeta;
		"description": metadata.PropertyMeta;
		"createdFrom": metadata.PropertyMeta;
		"createdTo": metadata.PropertyMeta;
		"signatory": metadata.PropertyMeta;
		"urgent": metadata.PropertyMeta;
		"monitored": metadata.PropertyMeta;
	};
}
export type InboxFilterNames = {
	readonly [P in keyof InboxFilterMeta["props"] | keyof InboxFilterMeta["complex"]]: string;
};

export class InboxFilter extends DomainObject {
	static meta: InboxFilterMeta;
	static NAMES: InboxFilterNames;
	meta: InboxFilterMeta;
	init(): void;
	"taskId": lang.ObservableProperty<string>;
	"taskType": lang.ObservableProperty<TaskType>;
	"documentType": lang.ObservableProperty<DocumentType>;
	"regNumber": lang.ObservableProperty<string>;
	"identifier": lang.ObservableProperty<string>;
	"description": lang.ObservableProperty<string>;
	"createdFrom": lang.ObservableProperty<Date>;
	"createdTo": lang.ObservableProperty<Date>;
	"signatory": lang.ObservableProperty<EmployeePosition>;
	"urgent": lang.ObservableProperty<boolean>;
	"monitored": lang.ObservableProperty<boolean>;
}

export interface EmployeeMeta extends metadata.EntityMeta {
	props: {
		"user": metadata.PropertyMeta;
		"firstName": metadata.PropertyMeta;
		"lastName": metadata.PropertyMeta;
		"patronymic": metadata.PropertyMeta;
		"displayName": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
		"phone": metadata.PropertyMeta;
		"email": metadata.PropertyMeta;
		"personnelNumber": metadata.PropertyMeta;
		"avatar": metadata.PropertyMeta;
		"localeName": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
		"employeePositions": metadata.PropertyMeta;
	};
}
export type EmployeeNames = {
	readonly [P in keyof EmployeeMeta["props"] | keyof EmployeeMeta["complex"]]: string;
};

export class Employee extends DomainObject {
	static meta: EmployeeMeta;
	static NAMES: EmployeeNames;
	meta: EmployeeMeta;
	init(): void;
	"user": lang.ObservableProperty<User>;
	"firstName": lang.ObservableProperty<string>;
	"lastName": lang.ObservableProperty<string>;
	"patronymic": lang.ObservableProperty<string>;
	"displayName": lang.ObservableProperty<string>;
	"deleted": lang.ObservableProperty<boolean>;
	"phone": lang.ObservableProperty<string>;
	"email": lang.ObservableProperty<string>;
	"personnelNumber": lang.ObservableProperty<string>;
	"avatar": lang.ObservableProperty<LobPropValue>;
	"localeName": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
	"employeePositions": lang.ObservableGetter<IDomainCollection<EmployeePosition>>;
}

export interface DeliveryOptionMeta extends metadata.EntityMeta {
	props: {
		"systemName": metadata.PropertyMeta;
		"name": metadata.PropertyMeta;
		"deliveryType": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type DeliveryOptionNames = {
	readonly [P in keyof DeliveryOptionMeta["props"] | keyof DeliveryOptionMeta["complex"]]: string;
};

export class DeliveryOption extends DomainObject {
	static meta: DeliveryOptionMeta;
	static NAMES: DeliveryOptionNames;
	meta: DeliveryOptionMeta;
	init(): void;
	"systemName": lang.ObservableProperty<string>;
	"name": lang.ObservableProperty<string>;
	"deliveryType": lang.ObservableProperty<DeliveryType>;
	"deleted": lang.ObservableProperty<boolean>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface RenditionMeta extends metadata.EntityMeta {
	props: {
		"externalId": metadata.PropertyMeta;
		"storageType": metadata.PropertyMeta;
		"content": metadata.PropertyMeta;
		"storedExternalId": metadata.PropertyMeta;
		"storedStorageType": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"modifyTime": metadata.PropertyMeta;
		"sourceAttachmentId": metadata.PropertyMeta;
		"additionalParams": metadata.PropertyMeta;
	};
}
export type RenditionNames = {
	readonly [P in keyof RenditionMeta["props"] | keyof RenditionMeta["complex"]]: string;
};

export class Rendition extends DomainObject {
	static meta: RenditionMeta;
	static NAMES: RenditionNames;
	meta: RenditionMeta;
	init(): void;
	"externalId": lang.ObservableProperty<string>;
	"storageType": lang.ObservableProperty<string>;
	"content": lang.ObservableProperty<LobPropValue>;
	"storedExternalId": lang.ObservableProperty<string>;
	"storedStorageType": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"modifyTime": lang.ObservableProperty<Date>;
	"sourceAttachmentId": lang.ObservableProperty<string>;
	"additionalParams": lang.ObservableProperty<string>;
}

export interface IncomingDocumentAddresseeMeta extends metadata.EntityMeta {
	props: {
		"document": metadata.PropertyMeta;
		"addressee": metadata.PropertyMeta;
		"incomingDocumentAddresseeStatus": metadata.PropertyMeta;
		"aclId": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type IncomingDocumentAddresseeNames = {
	readonly [P in keyof IncomingDocumentAddresseeMeta["props"] | keyof IncomingDocumentAddresseeMeta["complex"]]: string;
};

export class IncomingDocumentAddressee extends DomainObject {
	static meta: IncomingDocumentAddresseeMeta;
	static NAMES: IncomingDocumentAddresseeNames;
	meta: IncomingDocumentAddresseeMeta;
	init(): void;
	"document": lang.ObservableProperty<IncomingDocument>;
	"addressee": lang.ObservableProperty<EmployeePosition>;
	"incomingDocumentAddresseeStatus": lang.ObservableProperty<IncomingDocumentAddresseeStatus>;
	"aclId": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface SearchResultDocumentWithAttachmentsMeta extends metadata.EntityMeta {
	props: {
		"document": metadata.PropertyMeta;
		"attachments": metadata.PropertyMeta;
	};
}
export type SearchResultDocumentWithAttachmentsNames = {
	readonly [P in keyof SearchResultDocumentWithAttachmentsMeta["props"] | keyof SearchResultDocumentWithAttachmentsMeta["complex"]]: string;
};

export class SearchResultDocumentWithAttachments extends DomainObject {
	static meta: SearchResultDocumentWithAttachmentsMeta;
	static NAMES: SearchResultDocumentWithAttachmentsNames;
	meta: SearchResultDocumentWithAttachmentsMeta;
	init(): void;
	"document": lang.ObservableProperty<AbstractDocument>;
	"attachments": lang.ObservableGetter<IDomainCollection<DocumentAttachment>>;
}

export interface CurrencyFilterMeta extends metadata.EntityMeta {
	props: {
		"searchString": metadata.PropertyMeta;
		"allowDeleted": metadata.PropertyMeta;
	};
}
export type CurrencyFilterNames = {
	readonly [P in keyof CurrencyFilterMeta["props"] | keyof CurrencyFilterMeta["complex"]]: string;
};

export class CurrencyFilter extends DomainObject {
	static meta: CurrencyFilterMeta;
	static NAMES: CurrencyFilterNames;
	meta: CurrencyFilterMeta;
	init(): void;
	"searchString": lang.ObservableProperty<string>;
	"allowDeleted": lang.ObservableProperty<boolean>;
}

export interface DocumentSubTypeMeta extends metadata.EntityMeta {
	props: DocumentTypeMeta["props"] ;
	complex: DocumentTypeMeta["complex"] ;
}
export type DocumentSubTypeNames = {
	readonly [P in keyof DocumentSubTypeMeta["props"] | keyof DocumentSubTypeMeta["complex"]]: string;
};

export class DocumentSubType extends DocumentType {
	static meta: DocumentSubTypeMeta;
	static NAMES: DocumentSubTypeNames;
	meta: DocumentSubTypeMeta;
	init(): void;
}

export interface DashboardMeta extends metadata.EntityMeta {
	props: {
		"ownerId": metadata.PropertyMeta;
		"dashboardType": metadata.PropertyMeta;
		"params": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type DashboardNames = {
	readonly [P in keyof DashboardMeta["props"] | keyof DashboardMeta["complex"]]: string;
};

export class Dashboard extends DomainObject {
	static meta: DashboardMeta;
	static NAMES: DashboardNames;
	meta: DashboardMeta;
	init(): void;
	"ownerId": lang.ObservableProperty<string>;
	"dashboardType": lang.ObservableProperty<string>;
	"params": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface CreateDocumentProcessParamsMeta extends metadata.EntityMeta {
	props: {
		"organization": metadata.PropertyMeta;
		"subtype": metadata.PropertyMeta;
		"template": metadata.PropertyMeta;
	};
}
export type CreateDocumentProcessParamsNames = {
	readonly [P in keyof CreateDocumentProcessParamsMeta["props"] | keyof CreateDocumentProcessParamsMeta["complex"]]: string;
};

export class CreateDocumentProcessParams extends DomainObject {
	static meta: CreateDocumentProcessParamsMeta;
	static NAMES: CreateDocumentProcessParamsNames;
	meta: CreateDocumentProcessParamsMeta;
	init(): void;
	"organization": lang.ObservableProperty<Company>;
	"subtype": lang.ObservableProperty<DocumentSubType>;
	"template": lang.ObservableProperty<DocumentTemplate>;
}

export interface AbstractCorrespondentMeta extends metadata.EntityMeta {
	props: {
		"comment": metadata.PropertyMeta;
		"name": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
		"contacts": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type AbstractCorrespondentNames = {
	readonly [P in keyof AbstractCorrespondentMeta["props"] | keyof AbstractCorrespondentMeta["complex"]]: string;
};

export class AbstractCorrespondent extends DomainObject {
	static meta: AbstractCorrespondentMeta;
	static NAMES: AbstractCorrespondentNames;
	meta: AbstractCorrespondentMeta;
	init(): void;
	"comment": lang.ObservableProperty<string>;
	"name": lang.ObservableProperty<string>;
	"deleted": lang.ObservableProperty<boolean>;
	"contacts": lang.ObservableGetter<IDomainCollection<AbstractCorrespondentContact>>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface DocumentTypeTreeFilterMeta extends metadata.EntityMeta {
	props: {
		"company": metadata.PropertyMeta;
		"name": metadata.PropertyMeta;
		"allowDeleted": metadata.PropertyMeta;
	};
}
export type DocumentTypeTreeFilterNames = {
	readonly [P in keyof DocumentTypeTreeFilterMeta["props"] | keyof DocumentTypeTreeFilterMeta["complex"]]: string;
};

export class DocumentTypeTreeFilter extends DomainObject {
	static meta: DocumentTypeTreeFilterMeta;
	static NAMES: DocumentTypeTreeFilterNames;
	meta: DocumentTypeTreeFilterMeta;
	init(): void;
	"company": lang.ObservableProperty<Company>;
	"name": lang.ObservableProperty<string>;
	"allowDeleted": lang.ObservableProperty<boolean>;
}

export interface OrgStructureRootElementMeta extends metadata.EntityMeta {
	props: DepartmentMeta["props"] ;
	complex: DepartmentMeta["complex"] ;
}
export type OrgStructureRootElementNames = {
	readonly [P in keyof OrgStructureRootElementMeta["props"] | keyof OrgStructureRootElementMeta["complex"]]: string;
};

export class OrgStructureRootElement extends Department {
	static meta: OrgStructureRootElementMeta;
	static NAMES: OrgStructureRootElementNames;
	meta: OrgStructureRootElementMeta;
	init(): void;
}

export interface InboxViewItemMeta extends metadata.EntityMeta {
	props: {
		"taskEntityId": metadata.PropertyMeta;
		"taskEntityType": metadata.PropertyMeta;
		"hasAttachment": metadata.PropertyMeta;
		"urgent": metadata.PropertyMeta;
		"taskTypeId": metadata.PropertyMeta;
		"taskTypeSystemName": metadata.PropertyMeta;
		"taskTypeName": metadata.PropertyMeta;
		"documentKindId": metadata.PropertyMeta;
		"documentKindName": metadata.PropertyMeta;
		"documentTypeId": metadata.PropertyMeta;
		"documentTypeName": metadata.PropertyMeta;
		"regNumber": metadata.PropertyMeta;
		"identifier": metadata.PropertyMeta;
		"created": metadata.PropertyMeta;
		"modified": metadata.PropertyMeta;
		"dueTime": metadata.PropertyMeta;
		"performerId": metadata.PropertyMeta;
		"performerName": metadata.PropertyMeta;
		"description": metadata.PropertyMeta;
		"ownerId": metadata.PropertyMeta;
		"taskStatus": metadata.PropertyMeta;
		"commissionDescription": metadata.PropertyMeta;
		"documentRegDate": metadata.PropertyMeta;
		"lockedById": metadata.PropertyMeta;
		"lockedByType": metadata.PropertyMeta;
	};
}
export type InboxViewItemNames = {
	readonly [P in keyof InboxViewItemMeta["props"] | keyof InboxViewItemMeta["complex"]]: string;
};

export class InboxViewItem extends DomainObject {
	static meta: InboxViewItemMeta;
	static NAMES: InboxViewItemNames;
	meta: InboxViewItemMeta;
	init(): void;
	"taskEntityId": lang.ObservableProperty<string>;
	"taskEntityType": lang.ObservableProperty<string>;
	"hasAttachment": lang.ObservableProperty<boolean>;
	"urgent": lang.ObservableProperty<boolean>;
	"taskTypeId": lang.ObservableProperty<string>;
	"taskTypeSystemName": lang.ObservableProperty<string>;
	"taskTypeName": lang.ObservableProperty<string>;
	"documentKindId": lang.ObservableProperty<string>;
	"documentKindName": lang.ObservableProperty<string>;
	"documentTypeId": lang.ObservableProperty<string>;
	"documentTypeName": lang.ObservableProperty<string>;
	"regNumber": lang.ObservableProperty<string>;
	"identifier": lang.ObservableProperty<string>;
	"created": lang.ObservableProperty<Date>;
	"modified": lang.ObservableProperty<Date>;
	"dueTime": lang.ObservableProperty<Date>;
	"performerId": lang.ObservableProperty<string>;
	"performerName": lang.ObservableProperty<string>;
	"description": lang.ObservableProperty<string>;
	"ownerId": lang.ObservableProperty<string>;
	"taskStatus": lang.ObservableProperty<string>;
	"commissionDescription": lang.ObservableProperty<string>;
	"documentRegDate": lang.ObservableProperty<Date>;
	"lockedById": lang.ObservableProperty<string>;
	"lockedByType": lang.ObservableProperty<string>;
}

export interface AbstractCorrespondentContactMeta extends metadata.EntityMeta {
	props: {
		"correspondent": metadata.PropertyMeta;
		"discriminator": metadata.PropertyMeta;
		"name": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
		"contactType": metadata.PropertyMeta;
		"contactKind": metadata.PropertyMeta;
		"primary": metadata.PropertyMeta;
		"comment": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type AbstractCorrespondentContactNames = {
	readonly [P in keyof AbstractCorrespondentContactMeta["props"] | keyof AbstractCorrespondentContactMeta["complex"]]: string;
};

export class AbstractCorrespondentContact extends DomainObject {
	static meta: AbstractCorrespondentContactMeta;
	static NAMES: AbstractCorrespondentContactNames;
	meta: AbstractCorrespondentContactMeta;
	init(): void;
	"correspondent": lang.ObservableProperty<AbstractCorrespondent>;
	"discriminator": lang.ObservableProperty<string>;
	"name": lang.ObservableProperty<string>;
	"deleted": lang.ObservableProperty<boolean>;
	"contactType": lang.ObservableProperty<CorrespondentContactType>;
	"contactKind": lang.ObservableProperty<CorrespondentContactKind>;
	"primary": lang.ObservableProperty<boolean>;
	"comment": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface ContractorCreationParamsMeta extends metadata.EntityMeta {
	props: {
		"correspondent": metadata.PropertyMeta;
	};
}
export type ContractorCreationParamsNames = {
	readonly [P in keyof ContractorCreationParamsMeta["props"] | keyof ContractorCreationParamsMeta["complex"]]: string;
};

export class ContractorCreationParams extends DomainObject {
	static meta: ContractorCreationParamsMeta;
	static NAMES: ContractorCreationParamsNames;
	meta: ContractorCreationParamsMeta;
	init(): void;
	"correspondent": lang.ObservableProperty<CompanyCorrespondent>;
}

export interface OutgoingDocumentAddresseeMeta extends metadata.EntityMeta {
	props: {
		"document": metadata.PropertyMeta;
		"deliveryOption": metadata.PropertyMeta;
		"correspondent": metadata.PropertyMeta;
		"address": metadata.PropertyMeta;
		"fax": metadata.PropertyMeta;
		"email": metadata.PropertyMeta;
		"deliveryStatus": metadata.PropertyMeta;
		"aclId": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type OutgoingDocumentAddresseeNames = {
	readonly [P in keyof OutgoingDocumentAddresseeMeta["props"] | keyof OutgoingDocumentAddresseeMeta["complex"]]: string;
};

export class OutgoingDocumentAddressee extends DomainObject {
	static meta: OutgoingDocumentAddresseeMeta;
	static NAMES: OutgoingDocumentAddresseeNames;
	meta: OutgoingDocumentAddresseeMeta;
	init(): void;
	"document": lang.ObservableProperty<OutgoingDocument>;
	"deliveryOption": lang.ObservableProperty<DeliveryOption>;
	"correspondent": lang.ObservableProperty<AbstractCorrespondent>;
	"address": lang.ObservableProperty<CorrespondentAddress>;
	"fax": lang.ObservableProperty<CorrespondentContactDefault>;
	"email": lang.ObservableProperty<CorrespondentContactDefault>;
	"deliveryStatus": lang.ObservableProperty<OutgoingDocumentDeliveryStatus>;
	"aclId": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface ApproverMeta extends metadata.EntityMeta {
	props: {
		"approver": metadata.PropertyMeta;
		"queue": metadata.PropertyMeta;
		"createdOn": metadata.PropertyMeta;
		"decision": metadata.PropertyMeta;
		"state": metadata.PropertyMeta;
		"aclId": metadata.PropertyMeta;
		"queues": metadata.PropertyMeta;
	};
}
export type ApproverNames = {
	readonly [P in keyof ApproverMeta["props"] | keyof ApproverMeta["complex"]]: string;
};

export class Approver extends DomainObject {
	static meta: ApproverMeta;
	static NAMES: ApproverNames;
	meta: ApproverMeta;
	init(): void;
	"approver": lang.ObservableProperty<EmployeePosition>;
	"queue": lang.ObservableProperty<ApprovalQueue>;
	"createdOn": lang.ObservableProperty<ApprovalPlanningStage>;
	"decision": lang.ObservableProperty<ApprovalDecision>;
	"state": lang.ObservableProperty<ApprovalEntityState>;
	"aclId": lang.ObservableProperty<string>;
	"queues": lang.ObservableGetter<IDomainCollection<ApprovalQueue>>;
}

export interface ApprovalIterationMeta extends metadata.EntityMeta {
	props: {
		"document": metadata.PropertyMeta;
		"position": metadata.PropertyMeta;
		"state": metadata.PropertyMeta;
		"aclId": metadata.PropertyMeta;
		"queues": metadata.PropertyMeta;
	};
}
export type ApprovalIterationNames = {
	readonly [P in keyof ApprovalIterationMeta["props"] | keyof ApprovalIterationMeta["complex"]]: string;
};

export class ApprovalIteration extends DomainObject {
	static meta: ApprovalIterationMeta;
	static NAMES: ApprovalIterationNames;
	meta: ApprovalIterationMeta;
	init(): void;
	"document": lang.ObservableProperty<AbstractDocument>;
	"position": lang.ObservableProperty<number>;
	"state": lang.ObservableProperty<ApprovalEntityState>;
	"aclId": lang.ObservableProperty<string>;
	"queues": lang.ObservableGetter<IDomainCollection<ApprovalQueue>>;
}

export interface CompanyPersonCorrespondentMeta extends metadata.EntityMeta {
	props: AbstractCorrespondentMeta["props"] & {
		"parent": metadata.PropertyMeta;
		"firstName": metadata.PropertyMeta;
		"secondName": metadata.PropertyMeta;
		"patronymic": metadata.PropertyMeta;
		"position": metadata.PropertyMeta;
		"primary": metadata.PropertyMeta;
		"department": metadata.PropertyMeta;
		"name": metadata.PropertyMeta;
	};
	complex: AbstractCorrespondentMeta["complex"] ;
}
export type CompanyPersonCorrespondentNames = {
	readonly [P in keyof CompanyPersonCorrespondentMeta["props"] | keyof CompanyPersonCorrespondentMeta["complex"]]: string;
};

export class CompanyPersonCorrespondent extends AbstractCorrespondent {
	static meta: CompanyPersonCorrespondentMeta;
	static NAMES: CompanyPersonCorrespondentNames;
	meta: CompanyPersonCorrespondentMeta;
	init(): void;
	"parent": lang.ObservableProperty<CompanyCorrespondent>;
	"firstName": lang.ObservableProperty<string>;
	"secondName": lang.ObservableProperty<string>;
	"patronymic": lang.ObservableProperty<string>;
	"position": lang.ObservableProperty<string>;
	"primary": lang.ObservableProperty<boolean>;
	"department": lang.ObservableProperty<string>;
	"name": lang.ObservableProperty<string>;
}

export interface AssistantMeta extends metadata.EntityMeta {
	props: {
		"superior": metadata.PropertyMeta;
		"assistedBy": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type AssistantNames = {
	readonly [P in keyof AssistantMeta["props"] | keyof AssistantMeta["complex"]]: string;
};

export class Assistant extends DomainObject {
	static meta: AssistantMeta;
	static NAMES: AssistantNames;
	meta: AssistantMeta;
	init(): void;
	"superior": lang.ObservableProperty<EmployeePosition>;
	"assistedBy": lang.ObservableProperty<EmployeePosition>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface ContractRevokeReasonFilterMeta extends metadata.EntityMeta {
	props: {
		"searchString": metadata.PropertyMeta;
		"allowDeleted": metadata.PropertyMeta;
	};
}
export type ContractRevokeReasonFilterNames = {
	readonly [P in keyof ContractRevokeReasonFilterMeta["props"] | keyof ContractRevokeReasonFilterMeta["complex"]]: string;
};

export class ContractRevokeReasonFilter extends DomainObject {
	static meta: ContractRevokeReasonFilterMeta;
	static NAMES: ContractRevokeReasonFilterNames;
	meta: ContractRevokeReasonFilterMeta;
	init(): void;
	"searchString": lang.ObservableProperty<string>;
	"allowDeleted": lang.ObservableProperty<boolean>;
}

export interface CurrencyMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"codeAlfa": metadata.PropertyMeta;
		"codeNumber": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type CurrencyNames = {
	readonly [P in keyof CurrencyMeta["props"] | keyof CurrencyMeta["complex"]]: string;
};

export class Currency extends DomainObject {
	static meta: CurrencyMeta;
	static NAMES: CurrencyNames;
	meta: CurrencyMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"codeAlfa": lang.ObservableProperty<string>;
	"codeNumber": lang.ObservableProperty<string>;
	"deleted": lang.ObservableProperty<boolean>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface AbstractDocumentRelationMeta extends metadata.EntityMeta {
	props: {
		"relationType": metadata.PropertyMeta;
		"source": metadata.PropertyMeta;
		"aclId": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type AbstractDocumentRelationNames = {
	readonly [P in keyof AbstractDocumentRelationMeta["props"] | keyof AbstractDocumentRelationMeta["complex"]]: string;
};

export class AbstractDocumentRelation extends DomainObject {
	static meta: AbstractDocumentRelationMeta;
	static NAMES: AbstractDocumentRelationNames;
	meta: AbstractDocumentRelationMeta;
	init(): void;
	"relationType": lang.ObservableProperty<RelationType>;
	"source": lang.ObservableProperty<AbstractDocument>;
	"aclId": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface CommentMeta extends metadata.EntityMeta {
	props: {
		"parent": metadata.PropertyMeta;
		"entityId": metadata.PropertyMeta;
		"entityType": metadata.PropertyMeta;
		"author": metadata.PropertyMeta;
		"content": metadata.PropertyMeta;
		"resolved": metadata.PropertyMeta;
		"aclId": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type CommentNames = {
	readonly [P in keyof CommentMeta["props"] | keyof CommentMeta["complex"]]: string;
};

export class Comment extends DomainObject {
	static meta: CommentMeta;
	static NAMES: CommentNames;
	meta: CommentMeta;
	init(): void;
	"parent": lang.ObservableProperty<Comment>;
	"entityId": lang.ObservableProperty<string>;
	"entityType": lang.ObservableProperty<string>;
	"author": lang.ObservableProperty<Employee>;
	"content": lang.ObservableProperty<string>;
	"resolved": lang.ObservableProperty<boolean>;
	"aclId": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface DisciplineReportParamsMeta extends metadata.EntityMeta {
	props: AbstractReportParamsMeta["props"] & {
		"performers": metadata.PropertyMeta;
		"authors": metadata.PropertyMeta;
		"overseers": metadata.PropertyMeta;
		"createdDateFrom": metadata.PropertyMeta;
		"createdDateTo": metadata.PropertyMeta;
		"plannedDateFrom": metadata.PropertyMeta;
		"plannedDateTo": metadata.PropertyMeta;
		"documentTypes": metadata.PropertyMeta;
		"documentKinds": metadata.PropertyMeta;
		"groupByDocumentKind": metadata.PropertyMeta;
	};
	complex: AbstractReportParamsMeta["complex"] ;
}
export type DisciplineReportParamsNames = {
	readonly [P in keyof DisciplineReportParamsMeta["props"] | keyof DisciplineReportParamsMeta["complex"]]: string;
};

export class DisciplineReportParams extends AbstractReportParams {
	static meta: DisciplineReportParamsMeta;
	static NAMES: DisciplineReportParamsNames;
	meta: DisciplineReportParamsMeta;
	init(): void;
	"performers": lang.ObservableGetter<IDomainCollection<AbstractOrgStructureElement>>;
	"authors": lang.ObservableGetter<IDomainCollection<AbstractOrgStructureElement>>;
	"overseers": lang.ObservableGetter<IDomainCollection<AbstractOrgStructureElement>>;
	"createdDateFrom": lang.ObservableProperty<Date>;
	"createdDateTo": lang.ObservableProperty<Date>;
	"plannedDateFrom": lang.ObservableProperty<Date>;
	"plannedDateTo": lang.ObservableProperty<Date>;
	"documentTypes": lang.ObservableGetter<IDomainCollection<DocumentType>>;
	"documentKinds": lang.ObservableGetter<IDomainCollection<DocumentKind>>;
	"groupByDocumentKind": lang.ObservableProperty<boolean>;
}

export interface CommissionPerformerStatusMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"systemName": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type CommissionPerformerStatusNames = {
	readonly [P in keyof CommissionPerformerStatusMeta["props"] | keyof CommissionPerformerStatusMeta["complex"]]: string;
};

export class CommissionPerformerStatus extends DomainObject {
	static meta: CommissionPerformerStatusMeta;
	static NAMES: CommissionPerformerStatusNames;
	meta: CommissionPerformerStatusMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"systemName": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface CompanyMeta extends metadata.EntityMeta {
	props: DepartmentMeta["props"] & {
		"street": metadata.PropertyMeta;
		"building": metadata.PropertyMeta;
		"apartment": metadata.PropertyMeta;
		"city": metadata.PropertyMeta;
		"subregion": metadata.PropertyMeta;
		"region": metadata.PropertyMeta;
		"country": metadata.PropertyMeta;
		"postalCode": metadata.PropertyMeta;
		"email": metadata.PropertyMeta;
		"fax": metadata.PropertyMeta;
	};
	complex: DepartmentMeta["complex"] ;
}
export type CompanyNames = {
	readonly [P in keyof CompanyMeta["props"] | keyof CompanyMeta["complex"]]: string;
};

export class Company extends Department {
	static meta: CompanyMeta;
	static NAMES: CompanyNames;
	meta: CompanyMeta;
	init(): void;
	"street": lang.ObservableProperty<string>;
	"building": lang.ObservableProperty<string>;
	"apartment": lang.ObservableProperty<string>;
	"city": lang.ObservableProperty<string>;
	"subregion": lang.ObservableProperty<string>;
	"region": lang.ObservableProperty<string>;
	"country": lang.ObservableProperty<string>;
	"postalCode": lang.ObservableProperty<string>;
	"email": lang.ObservableProperty<string>;
	"fax": lang.ObservableProperty<string>;
}

export interface PositionDescriptionMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type PositionDescriptionNames = {
	readonly [P in keyof PositionDescriptionMeta["props"] | keyof PositionDescriptionMeta["complex"]]: string;
};

export class PositionDescription extends DomainObject {
	static meta: PositionDescriptionMeta;
	static NAMES: PositionDescriptionNames;
	meta: PositionDescriptionMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"deleted": lang.ObservableProperty<boolean>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface DocumentAttachmentMeta extends metadata.EntityMeta {
	props: AttachmentMeta["props"] & {
		"document": metadata.PropertyMeta;
		"primary": metadata.PropertyMeta;
		"versionKey": metadata.PropertyMeta;
		"versionLabel": metadata.PropertyMeta;
		"author": metadata.PropertyMeta;
		"aclId": metadata.PropertyMeta;
		"lockInfo": metadata.PropertyMeta;
	};
	complex: AttachmentMeta["complex"] ;
}
export type DocumentAttachmentNames = {
	readonly [P in keyof DocumentAttachmentMeta["props"] | keyof DocumentAttachmentMeta["complex"]]: string;
};

export class DocumentAttachment extends Attachment {
	static meta: DocumentAttachmentMeta;
	static NAMES: DocumentAttachmentNames;
	meta: DocumentAttachmentMeta;
	init(): void;
	"document": lang.ObservableProperty<AbstractDocument>;
	"primary": lang.ObservableProperty<boolean>;
	"versionKey": lang.ObservableProperty<string>;
	"versionLabel": lang.ObservableProperty<number>;
	"author": lang.ObservableProperty<EmployeePosition>;
	"aclId": lang.ObservableProperty<string>;
	"lockInfo": lang.ObservableProperty<LockInfoDefault>;
}

export interface CommissionPerformerReportStatusMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"systemName": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type CommissionPerformerReportStatusNames = {
	readonly [P in keyof CommissionPerformerReportStatusMeta["props"] | keyof CommissionPerformerReportStatusMeta["complex"]]: string;
};

export class CommissionPerformerReportStatus extends DomainObject {
	static meta: CommissionPerformerReportStatusMeta;
	static NAMES: CommissionPerformerReportStatusNames;
	meta: CommissionPerformerReportStatusMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"systemName": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface ContractDocumentContractorMeta extends metadata.EntityMeta {
	props: {
		"document": metadata.PropertyMeta;
		"contractor": metadata.PropertyMeta;
		"number": metadata.PropertyMeta;
		"signingDate": metadata.PropertyMeta;
		"signerName": metadata.PropertyMeta;
		"warrantName": metadata.PropertyMeta;
		"aclId": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type ContractDocumentContractorNames = {
	readonly [P in keyof ContractDocumentContractorMeta["props"] | keyof ContractDocumentContractorMeta["complex"]]: string;
};

export class ContractDocumentContractor extends DomainObject {
	static meta: ContractDocumentContractorMeta;
	static NAMES: ContractDocumentContractorNames;
	meta: ContractDocumentContractorMeta;
	init(): void;
	"document": lang.ObservableProperty<ContractDocument>;
	"contractor": lang.ObservableProperty<Contractor>;
	"number": lang.ObservableProperty<string>;
	"signingDate": lang.ObservableProperty<Date>;
	"signerName": lang.ObservableProperty<string>;
	"warrantName": lang.ObservableProperty<string>;
	"aclId": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface DocumentProcessTypeFakeModelMeta extends metadata.EntityMeta {
	props: {
		"processType": metadata.PropertyMeta;
	};
}
export type DocumentProcessTypeFakeModelNames = {
	readonly [P in keyof DocumentProcessTypeFakeModelMeta["props"] | keyof DocumentProcessTypeFakeModelMeta["complex"]]: string;
};

export class DocumentProcessTypeFakeModel extends DomainObject {
	static meta: DocumentProcessTypeFakeModelMeta;
	static NAMES: DocumentProcessTypeFakeModelNames;
	meta: DocumentProcessTypeFakeModelMeta;
	init(): void;
	"processType": lang.ObservableProperty<DocumentProcessType>;
}

export interface OutgoingDocumentJournalFilterMeta extends metadata.EntityMeta {
	props: {
		"regNumber": metadata.PropertyMeta;
		"identifier": metadata.PropertyMeta;
		"summary": metadata.PropertyMeta;
		"status": metadata.PropertyMeta;
		"performer": metadata.PropertyMeta;
		"regDateFrom": metadata.PropertyMeta;
		"regDateTo": metadata.PropertyMeta;
		"createdFrom": metadata.PropertyMeta;
		"createdTo": metadata.PropertyMeta;
		"correspondent": metadata.PropertyMeta;
		"nomenclatureCase": metadata.PropertyMeta;
	};
}
export type OutgoingDocumentJournalFilterNames = {
	readonly [P in keyof OutgoingDocumentJournalFilterMeta["props"] | keyof OutgoingDocumentJournalFilterMeta["complex"]]: string;
};

export class OutgoingDocumentJournalFilter extends DomainObject {
	static meta: OutgoingDocumentJournalFilterMeta;
	static NAMES: OutgoingDocumentJournalFilterNames;
	meta: OutgoingDocumentJournalFilterMeta;
	init(): void;
	"regNumber": lang.ObservableProperty<string>;
	"identifier": lang.ObservableProperty<string>;
	"summary": lang.ObservableProperty<string>;
	"status": lang.ObservableProperty<DocumentStatus>;
	"performer": lang.ObservableProperty<EmployeePosition>;
	"regDateFrom": lang.ObservableProperty<Date>;
	"regDateTo": lang.ObservableProperty<Date>;
	"createdFrom": lang.ObservableProperty<Date>;
	"createdTo": lang.ObservableProperty<Date>;
	"correspondent": lang.ObservableProperty<AbstractCorrespondent>;
	"nomenclatureCase": lang.ObservableProperty<NomenclatureCase>;
}

export interface AbstractDocumentMeta extends metadata.EntityMeta {
	props: {
		"discriminator": metadata.PropertyMeta;
		"documentKind": metadata.PropertyMeta;
		"documentType": metadata.PropertyMeta;
		"identifier": metadata.PropertyMeta;
		"creationDate": metadata.PropertyMeta;
		"regNumber": metadata.PropertyMeta;
		"regDate": metadata.PropertyMeta;
		"summary": metadata.PropertyMeta;
		"organization": metadata.PropertyMeta;
		"author": metadata.PropertyMeta;
		"status": metadata.PropertyMeta;
		"permission": metadata.PropertyMeta;
		"aclId": metadata.PropertyMeta;
		"nomenclatureCase": metadata.PropertyMeta;
		"attachment": metadata.PropertyMeta;
		"relations": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type AbstractDocumentNames = {
	readonly [P in keyof AbstractDocumentMeta["props"] | keyof AbstractDocumentMeta["complex"]]: string;
};

export class AbstractDocument extends DomainObject {
	static meta: AbstractDocumentMeta;
	static NAMES: AbstractDocumentNames;
	meta: AbstractDocumentMeta;
	init(): void;
	"discriminator": lang.ObservableProperty<string>;
	"documentKind": lang.ObservableProperty<DocumentKind>;
	"documentType": lang.ObservableProperty<DocumentSubType>;
	"identifier": lang.ObservableProperty<string>;
	"creationDate": lang.ObservableProperty<Date>;
	"regNumber": lang.ObservableProperty<string>;
	"regDate": lang.ObservableProperty<Date>;
	"summary": lang.ObservableProperty<string>;
	"organization": lang.ObservableProperty<Company>;
	"author": lang.ObservableProperty<EmployeePosition>;
	"status": lang.ObservableProperty<DocumentStatus>;
	"permission": lang.ObservableProperty<DocumentPermission>;
	"aclId": lang.ObservableProperty<string>;
	"nomenclatureCase": lang.ObservableProperty<NomenclatureCase>;
	"attachment": lang.ObservableGetter<IDomainCollection<DocumentAttachment>>;
	"relations": lang.ObservableGetter<IDomainCollection<AbstractDocumentRelation>>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface LockInfoDefaultMeta extends metadata.EntityMeta {
	props: {
		"lockedObjectType": metadata.PropertyMeta;
		"lockType": metadata.PropertyMeta;
		"lockedById": metadata.PropertyMeta;
		"details": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type LockInfoDefaultNames = {
	readonly [P in keyof LockInfoDefaultMeta["props"] | keyof LockInfoDefaultMeta["complex"]]: string;
};

export class LockInfoDefault extends DomainObject {
	static meta: LockInfoDefaultMeta;
	static NAMES: LockInfoDefaultNames;
	meta: LockInfoDefaultMeta;
	init(): void;
	"lockedObjectType": lang.ObservableProperty<string>;
	"lockType": lang.ObservableProperty<string>;
	"lockedById": lang.ObservableProperty<string>;
	"details": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface TempContentMeta extends metadata.EntityMeta {
	props: {
		"storageType": metadata.PropertyMeta;
		"externalId": metadata.PropertyMeta;
		"storedExternalId": metadata.PropertyMeta;
		"storedStorageType": metadata.PropertyMeta;
		"content": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"userName": metadata.PropertyMeta;
		"masterContent": metadata.PropertyMeta;
		"dependentContent": metadata.PropertyMeta;
		"additionalParams": metadata.PropertyMeta;
	};
}
export type TempContentNames = {
	readonly [P in keyof TempContentMeta["props"] | keyof TempContentMeta["complex"]]: string;
};

export class TempContent extends DomainObject {
	static meta: TempContentMeta;
	static NAMES: TempContentNames;
	meta: TempContentMeta;
	init(): void;
	"storageType": lang.ObservableProperty<string>;
	"externalId": lang.ObservableProperty<string>;
	"storedExternalId": lang.ObservableProperty<string>;
	"storedStorageType": lang.ObservableProperty<string>;
	"content": lang.ObservableProperty<LobPropValue>;
	"creationTime": lang.ObservableProperty<Date>;
	"userName": lang.ObservableProperty<string>;
	"masterContent": lang.ObservableProperty<TempContent>;
	"dependentContent": lang.ObservableGetter<IDomainCollection<TempContent>>;
	"additionalParams": lang.ObservableProperty<string>;
}

export interface CommissionPerformerMeta extends metadata.EntityMeta {
	props: {
		"commission": metadata.PropertyMeta;
		"performer": metadata.PropertyMeta;
		"mainPerformer": metadata.PropertyMeta;
		"status": metadata.PropertyMeta;
		"deadline": metadata.PropertyMeta;
		"completed": metadata.PropertyMeta;
		"lastReportSent": metadata.PropertyMeta;
		"aclId": metadata.PropertyMeta;
		"reports": metadata.PropertyMeta;
		"childCommissions": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type CommissionPerformerNames = {
	readonly [P in keyof CommissionPerformerMeta["props"] | keyof CommissionPerformerMeta["complex"]]: string;
};

export class CommissionPerformer extends DomainObject {
	static meta: CommissionPerformerMeta;
	static NAMES: CommissionPerformerNames;
	meta: CommissionPerformerMeta;
	init(): void;
	"commission": lang.ObservableProperty<Commission>;
	"performer": lang.ObservableProperty<EmployeePosition>;
	"mainPerformer": lang.ObservableProperty<boolean>;
	"status": lang.ObservableProperty<CommissionPerformerStatus>;
	"deadline": lang.ObservableProperty<Date>;
	"completed": lang.ObservableProperty<Date>;
	"lastReportSent": lang.ObservableProperty<Date>;
	"aclId": lang.ObservableProperty<string>;
	"reports": lang.ObservableGetter<IDomainCollection<CommissionPerformerReport>>;
	"childCommissions": lang.ObservableGetter<IDomainCollection<Commission>>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface WeekBasedWorkingCalendarDateIntervalMeta extends metadata.EntityMeta {
	props: {
		"calendar": metadata.PropertyMeta;
		"intervalType": metadata.PropertyMeta;
		"date": metadata.PropertyMeta;
		"begin": metadata.PropertyMeta;
		"end": metadata.PropertyMeta;
		"description": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type WeekBasedWorkingCalendarDateIntervalNames = {
	readonly [P in keyof WeekBasedWorkingCalendarDateIntervalMeta["props"] | keyof WeekBasedWorkingCalendarDateIntervalMeta["complex"]]: string;
};

export class WeekBasedWorkingCalendarDateInterval extends DomainObject {
	static meta: WeekBasedWorkingCalendarDateIntervalMeta;
	static NAMES: WeekBasedWorkingCalendarDateIntervalNames;
	meta: WeekBasedWorkingCalendarDateIntervalMeta;
	init(): void;
	"calendar": lang.ObservableProperty<WeekBasedWorkingCalendar>;
	"intervalType": lang.ObservableProperty<WeekBasedWorkingCalendarIntervalTypeNames>;
	"date": lang.ObservableProperty<Date>;
	"begin": lang.ObservableProperty<Date>;
	"end": lang.ObservableProperty<Date>;
	"description": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface CorrespondentAddressMeta extends metadata.EntityMeta {
	props: AbstractCorrespondentContactMeta["props"] & {
		"country": metadata.PropertyMeta;
		"region": metadata.PropertyMeta;
		"subregion": metadata.PropertyMeta;
		"city": metadata.PropertyMeta;
		"street": metadata.PropertyMeta;
		"building": metadata.PropertyMeta;
		"appartment": metadata.PropertyMeta;
		"postalCode": metadata.PropertyMeta;
	};
	complex: AbstractCorrespondentContactMeta["complex"] ;
}
export type CorrespondentAddressNames = {
	readonly [P in keyof CorrespondentAddressMeta["props"] | keyof CorrespondentAddressMeta["complex"]]: string;
};

export class CorrespondentAddress extends AbstractCorrespondentContact {
	static meta: CorrespondentAddressMeta;
	static NAMES: CorrespondentAddressNames;
	meta: CorrespondentAddressMeta;
	init(): void;
	"country": lang.ObservableProperty<string>;
	"region": lang.ObservableProperty<string>;
	"subregion": lang.ObservableProperty<string>;
	"city": lang.ObservableProperty<string>;
	"street": lang.ObservableProperty<string>;
	"building": lang.ObservableProperty<string>;
	"appartment": lang.ObservableProperty<string>;
	"postalCode": lang.ObservableProperty<string>;
}

export interface CommissionMeta extends metadata.EntityMeta {
	props: {
		"parent": metadata.PropertyMeta;
		"description": metadata.PropertyMeta;
		"status": metadata.PropertyMeta;
		"creator": metadata.PropertyMeta;
		"author": metadata.PropertyMeta;
		"overseer": metadata.PropertyMeta;
		"reportShouldBeCheckedByAuthor": metadata.PropertyMeta;
		"deadline": metadata.PropertyMeta;
		"toFamiliarize": metadata.PropertyMeta;
		"completed": metadata.PropertyMeta;
		"creationDate": metadata.PropertyMeta;
		"sent": metadata.PropertyMeta;
		"regNumber": metadata.PropertyMeta;
		"reasonToRevoke": metadata.PropertyMeta;
		"container": metadata.PropertyMeta;
		"performers": metadata.PropertyMeta;
		"aclId": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type CommissionNames = {
	readonly [P in keyof CommissionMeta["props"] | keyof CommissionMeta["complex"]]: string;
};

export class Commission extends DomainObject {
	static meta: CommissionMeta;
	static NAMES: CommissionNames;
	meta: CommissionMeta;
	init(): void;
	"parent": lang.ObservableProperty<CommissionPerformer>;
	"description": lang.ObservableProperty<string>;
	"status": lang.ObservableProperty<CommissionStatus>;
	"creator": lang.ObservableProperty<EmployeePosition>;
	"author": lang.ObservableProperty<EmployeePosition>;
	"overseer": lang.ObservableProperty<EmployeePosition>;
	"reportShouldBeCheckedByAuthor": lang.ObservableProperty<boolean>;
	"deadline": lang.ObservableProperty<Date>;
	"toFamiliarize": lang.ObservableProperty<boolean>;
	"completed": lang.ObservableProperty<Date>;
	"creationDate": lang.ObservableProperty<Date>;
	"sent": lang.ObservableProperty<Date>;
	"regNumber": lang.ObservableProperty<string>;
	"reasonToRevoke": lang.ObservableProperty<string>;
	"container": lang.ObservableProperty<AbstractDocument>;
	"performers": lang.ObservableGetter<IDomainCollection<CommissionPerformer>>;
	"aclId": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface BookmarkMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"iconCode": metadata.PropertyMeta;
		"type": metadata.PropertyMeta;
		"params": metadata.PropertyMeta;
		"employee": metadata.PropertyMeta;
	};
}
export type BookmarkNames = {
	readonly [P in keyof BookmarkMeta["props"] | keyof BookmarkMeta["complex"]]: string;
};

export class Bookmark extends DomainObject {
	static meta: BookmarkMeta;
	static NAMES: BookmarkNames;
	meta: BookmarkMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"iconCode": lang.ObservableProperty<string>;
	"type": lang.ObservableProperty<BookmarkType>;
	"params": lang.ObservableProperty<string>;
	"employee": lang.ObservableProperty<Employee>;
}

export interface ApprovalDecisionMeta extends metadata.EntityMeta {
	props: {
		"decisionType": metadata.PropertyMeta;
		"comment": metadata.PropertyMeta;
		"response": metadata.PropertyMeta;
		"approver": metadata.PropertyMeta;
		"performer": metadata.PropertyMeta;
		"aclId": metadata.PropertyMeta;
		"decisionTime": metadata.PropertyMeta;
	};
}
export type ApprovalDecisionNames = {
	readonly [P in keyof ApprovalDecisionMeta["props"] | keyof ApprovalDecisionMeta["complex"]]: string;
};

export class ApprovalDecision extends DomainObject {
	static meta: ApprovalDecisionMeta;
	static NAMES: ApprovalDecisionNames;
	meta: ApprovalDecisionMeta;
	init(): void;
	"decisionType": lang.ObservableProperty<ApprovalDecisionType>;
	"comment": lang.ObservableProperty<string>;
	"response": lang.ObservableProperty<string>;
	"approver": lang.ObservableProperty<Approver>;
	"performer": lang.ObservableProperty<EmployeePosition>;
	"aclId": lang.ObservableProperty<string>;
	"decisionTime": lang.ObservableProperty<Date>;
}

export interface AbstractOrgStructureElementMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type AbstractOrgStructureElementNames = {
	readonly [P in keyof AbstractOrgStructureElementMeta["props"] | keyof AbstractOrgStructureElementMeta["complex"]]: string;
};

export class AbstractOrgStructureElement extends DomainObject {
	static meta: AbstractOrgStructureElementMeta;
	static NAMES: AbstractOrgStructureElementNames;
	meta: AbstractOrgStructureElementMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"deleted": lang.ObservableProperty<boolean>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface CorrespondentContactDefaultMeta extends metadata.EntityMeta {
	props: AbstractCorrespondentContactMeta["props"] ;
	complex: AbstractCorrespondentContactMeta["complex"] ;
}
export type CorrespondentContactDefaultNames = {
	readonly [P in keyof CorrespondentContactDefaultMeta["props"] | keyof CorrespondentContactDefaultMeta["complex"]]: string;
};

export class CorrespondentContactDefault extends AbstractCorrespondentContact {
	static meta: CorrespondentContactDefaultMeta;
	static NAMES: CorrespondentContactDefaultNames;
	meta: CorrespondentContactDefaultMeta;
	init(): void;
}

export interface SmartSearchFilterMeta extends metadata.EntityMeta {
	props: {
		"searchString": metadata.PropertyMeta;
		"searchType": metadata.PropertyMeta;
		"documentTypeId": metadata.PropertyMeta;
		"searchInCommissions": metadata.PropertyMeta;
	};
}
export type SmartSearchFilterNames = {
	readonly [P in keyof SmartSearchFilterMeta["props"] | keyof SmartSearchFilterMeta["complex"]]: string;
};

export class SmartSearchFilter extends DomainObject {
	static meta: SmartSearchFilterMeta;
	static NAMES: SmartSearchFilterNames;
	meta: SmartSearchFilterMeta;
	init(): void;
	"searchString": lang.ObservableProperty<string>;
	"searchType": lang.ObservableProperty<SearchType>;
	"documentTypeId": lang.ObservableProperty<string>;
	"searchInCommissions": lang.ObservableProperty<boolean>;
}

export interface WeekBasedWorkingCalendarMeta extends metadata.EntityMeta {
	props: {
		"description": metadata.PropertyMeta;
		"systemName": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
		"intervals": metadata.PropertyMeta;
		"exceptions": metadata.PropertyMeta;
	};
}
export type WeekBasedWorkingCalendarNames = {
	readonly [P in keyof WeekBasedWorkingCalendarMeta["props"] | keyof WeekBasedWorkingCalendarMeta["complex"]]: string;
};

export class WeekBasedWorkingCalendar extends DomainObject {
	static meta: WeekBasedWorkingCalendarMeta;
	static NAMES: WeekBasedWorkingCalendarNames;
	meta: WeekBasedWorkingCalendarMeta;
	init(): void;
	"description": lang.ObservableProperty<string>;
	"systemName": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
	"intervals": lang.ObservableGetter<IDomainCollection<WeekBasedWorkingCalendarDayInterval>>;
	"exceptions": lang.ObservableGetter<IDomainCollection<WeekBasedWorkingCalendarDateInterval>>;
}

export interface ReportMeta extends metadata.EntityMeta {
	props: {
		"author": metadata.PropertyMeta;
		"reportContainers": metadata.PropertyMeta;
		"deletionTime": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type ReportNames = {
	readonly [P in keyof ReportMeta["props"] | keyof ReportMeta["complex"]]: string;
};

export class Report extends DomainObject {
	static meta: ReportMeta;
	static NAMES: ReportNames;
	meta: ReportMeta;
	init(): void;
	"author": lang.ObservableProperty<User>;
	"reportContainers": lang.ObservableGetter<IDomainCollection<ReportContent>>;
	"deletionTime": lang.ObservableProperty<Date>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface ReportContentMeta extends metadata.EntityMeta {
	props: {
		"report": metadata.PropertyMeta;
		"name": metadata.PropertyMeta;
		"storedExternalId": metadata.PropertyMeta;
		"storedStorageType": metadata.PropertyMeta;
		"contentId": metadata.PropertyMeta;
		"content": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
	};
}
export type ReportContentNames = {
	readonly [P in keyof ReportContentMeta["props"] | keyof ReportContentMeta["complex"]]: string;
};

export class ReportContent extends DomainObject {
	static meta: ReportContentMeta;
	static NAMES: ReportContentNames;
	meta: ReportContentMeta;
	init(): void;
	"report": lang.ObservableProperty<Report>;
	"name": lang.ObservableProperty<string>;
	"storedExternalId": lang.ObservableProperty<string>;
	"storedStorageType": lang.ObservableProperty<string>;
	"contentId": lang.ObservableProperty<string>;
	"content": lang.ObservableProperty<LobPropValue>;
	"creationTime": lang.ObservableProperty<Date>;
}

export interface ContractorMeta extends metadata.EntityMeta {
	props: {
		"correspondent": metadata.PropertyMeta;
		"name": metadata.PropertyMeta;
		"shortName": metadata.PropertyMeta;
		"ogrn": metadata.PropertyMeta;
		"inn": metadata.PropertyMeta;
		"kpp": metadata.PropertyMeta;
		"comment": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type ContractorNames = {
	readonly [P in keyof ContractorMeta["props"] | keyof ContractorMeta["complex"]]: string;
};

export class Contractor extends DomainObject {
	static meta: ContractorMeta;
	static NAMES: ContractorNames;
	meta: ContractorMeta;
	init(): void;
	"correspondent": lang.ObservableProperty<CompanyCorrespondent>;
	"name": lang.ObservableProperty<string>;
	"shortName": lang.ObservableProperty<string>;
	"ogrn": lang.ObservableProperty<string>;
	"inn": lang.ObservableProperty<string>;
	"kpp": lang.ObservableProperty<string>;
	"comment": lang.ObservableProperty<string>;
	"deleted": lang.ObservableProperty<boolean>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface CommonTaskCommandMeta extends metadata.EntityMeta {
	props: {
		"command": metadata.PropertyMeta;
		"taskId": metadata.PropertyMeta;
	};
}
export type CommonTaskCommandNames = {
	readonly [P in keyof CommonTaskCommandMeta["props"] | keyof CommonTaskCommandMeta["complex"]]: string;
};

export class CommonTaskCommand extends DomainObject {
	static meta: CommonTaskCommandMeta;
	static NAMES: CommonTaskCommandNames;
	meta: CommonTaskCommandMeta;
	init(): void;
	"command": lang.ObservableProperty<string>;
	"taskId": lang.ObservableProperty<string>;
}

export interface TaskTypeMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"systemName": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type TaskTypeNames = {
	readonly [P in keyof TaskTypeMeta["props"] | keyof TaskTypeMeta["complex"]]: string;
};

export class TaskType extends DomainObject {
	static meta: TaskTypeMeta;
	static NAMES: TaskTypeNames;
	meta: TaskTypeMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"systemName": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface DocumentKindMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
		"documentTypes": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type DocumentKindNames = {
	readonly [P in keyof DocumentKindMeta["props"] | keyof DocumentKindMeta["complex"]]: string;
};

export class DocumentKind extends DomainObject {
	static meta: DocumentKindMeta;
	static NAMES: DocumentKindNames;
	meta: DocumentKindMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"deleted": lang.ObservableProperty<boolean>;
	"documentTypes": lang.ObservableGetter<IDomainCollection<DocumentType>>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface AccessorsGroupItemMeta extends metadata.EntityMeta {
	props: {
		"group": metadata.PropertyMeta;
		"accessorId": metadata.PropertyMeta;
		"accessorType": metadata.PropertyMeta;
	};
}
export type AccessorsGroupItemNames = {
	readonly [P in keyof AccessorsGroupItemMeta["props"] | keyof AccessorsGroupItemMeta["complex"]]: string;
};

export class AccessorsGroupItem extends DomainObject {
	static meta: AccessorsGroupItemMeta;
	static NAMES: AccessorsGroupItemNames;
	meta: AccessorsGroupItemMeta;
	init(): void;
	"group": lang.ObservableProperty<AccessorsGroup>;
	"accessorId": lang.ObservableProperty<string>;
	"accessorType": lang.ObservableProperty<string>;
}

export interface RegNumberTemplateMeta extends metadata.EntityMeta {
	props: {
		"template": metadata.PropertyMeta;
		"type": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type RegNumberTemplateNames = {
	readonly [P in keyof RegNumberTemplateMeta["props"] | keyof RegNumberTemplateMeta["complex"]]: string;
};

export class RegNumberTemplate extends DomainObject {
	static meta: RegNumberTemplateMeta;
	static NAMES: RegNumberTemplateNames;
	meta: RegNumberTemplateMeta;
	init(): void;
	"template": lang.ObservableProperty<string>;
	"type": lang.ObservableProperty<DocumentType>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface DocumentToDocumentRelationMeta extends metadata.EntityMeta {
	props: AbstractDocumentRelationMeta["props"] & {
		"target": metadata.PropertyMeta;
		"reverse": metadata.PropertyMeta;
	};
	complex: AbstractDocumentRelationMeta["complex"] ;
}
export type DocumentToDocumentRelationNames = {
	readonly [P in keyof DocumentToDocumentRelationMeta["props"] | keyof DocumentToDocumentRelationMeta["complex"]]: string;
};

export class DocumentToDocumentRelation extends AbstractDocumentRelation {
	static meta: DocumentToDocumentRelationMeta;
	static NAMES: DocumentToDocumentRelationNames;
	meta: DocumentToDocumentRelationMeta;
	init(): void;
	"target": lang.ObservableProperty<AbstractDocument>;
	"reverse": lang.ObservableProperty<DocumentToDocumentRelation>;
}

export interface AttachmentMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"externalId": metadata.PropertyMeta;
		"storageType": metadata.PropertyMeta;
		"storedExternalId": metadata.PropertyMeta;
		"storedStorageType": metadata.PropertyMeta;
		"content": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"modifyTime": metadata.PropertyMeta;
	};
}
export type AttachmentNames = {
	readonly [P in keyof AttachmentMeta["props"] | keyof AttachmentMeta["complex"]]: string;
};

export class Attachment extends DomainObject {
	static meta: AttachmentMeta;
	static NAMES: AttachmentNames;
	meta: AttachmentMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"externalId": lang.ObservableProperty<string>;
	"storageType": lang.ObservableProperty<string>;
	"storedExternalId": lang.ObservableProperty<string>;
	"storedStorageType": lang.ObservableProperty<string>;
	"content": lang.ObservableProperty<LobPropValue>;
	"creationTime": lang.ObservableProperty<Date>;
	"modifyTime": lang.ObservableProperty<Date>;
}

export interface ReportGenerationTaskMeta extends metadata.EntityMeta {
	props: {
		"status": metadata.PropertyMeta;
		"createdDate": metadata.PropertyMeta;
		"owner": metadata.PropertyMeta;
		"taskTypeId": metadata.PropertyMeta;
		"report": metadata.PropertyMeta;
	};
}
export type ReportGenerationTaskNames = {
	readonly [P in keyof ReportGenerationTaskMeta["props"] | keyof ReportGenerationTaskMeta["complex"]]: string;
};

export class ReportGenerationTask extends DomainObject {
	static meta: ReportGenerationTaskMeta;
	static NAMES: ReportGenerationTaskNames;
	meta: ReportGenerationTaskMeta;
	init(): void;
	"status": lang.ObservableProperty<ReportGenerationStatus>;
	"createdDate": lang.ObservableProperty<Date>;
	"owner": lang.ObservableProperty<User>;
	"taskTypeId": lang.ObservableProperty<string>;
	"report": lang.ObservableProperty<Report>;
}

export interface RegisterDocumentProcessParamsMeta extends metadata.EntityMeta {
	props: {
		"organization": metadata.PropertyMeta;
		"subtype": metadata.PropertyMeta;
	};
}
export type RegisterDocumentProcessParamsNames = {
	readonly [P in keyof RegisterDocumentProcessParamsMeta["props"] | keyof RegisterDocumentProcessParamsMeta["complex"]]: string;
};

export class RegisterDocumentProcessParams extends DomainObject {
	static meta: RegisterDocumentProcessParamsMeta;
	static NAMES: RegisterDocumentProcessParamsNames;
	meta: RegisterDocumentProcessParamsMeta;
	init(): void;
	"organization": lang.ObservableProperty<Company>;
	"subtype": lang.ObservableProperty<DocumentSubType>;
}

export interface RoleParamDescriptorDefaultMeta extends metadata.EntityMeta {
	props: {
		"parent": metadata.PropertyMeta;
		"paramName": metadata.PropertyMeta;
		"paramTypeName": metadata.PropertyMeta;
		"nullable": metadata.PropertyMeta;
		"description": metadata.PropertyMeta;
	};
}
export type RoleParamDescriptorDefaultNames = {
	readonly [P in keyof RoleParamDescriptorDefaultMeta["props"] | keyof RoleParamDescriptorDefaultMeta["complex"]]: string;
};

export class RoleParamDescriptorDefault extends DomainObject {
	static meta: RoleParamDescriptorDefaultMeta;
	static NAMES: RoleParamDescriptorDefaultNames;
	meta: RoleParamDescriptorDefaultMeta;
	init(): void;
	"parent": lang.ObservableProperty<RoleDescriptorDefault>;
	"paramName": lang.ObservableProperty<string>;
	"paramTypeName": lang.ObservableProperty<string>;
	"nullable": lang.ObservableProperty<boolean>;
	"description": lang.ObservableProperty<string>;
}

export interface IncomingDocumentMeta extends metadata.EntityMeta {
	props: AbstractDocumentMeta["props"] & {
		"envelopeNumber": metadata.PropertyMeta;
		"incomingDate": metadata.PropertyMeta;
		"deliveryOption": metadata.PropertyMeta;
		"referenceNumber": metadata.PropertyMeta;
		"referenceDate": metadata.PropertyMeta;
		"correspondentExternal": metadata.PropertyMeta;
		"signedByExternal": metadata.PropertyMeta;
		"registrator": metadata.PropertyMeta;
		"sheetsAmount": metadata.PropertyMeta;
		"annexSheetsAmount": metadata.PropertyMeta;
		"reviewDeadlineDate": metadata.PropertyMeta;
		"addressees": metadata.PropertyMeta;
	};
	complex: AbstractDocumentMeta["complex"] ;
}
export type IncomingDocumentNames = {
	readonly [P in keyof IncomingDocumentMeta["props"] | keyof IncomingDocumentMeta["complex"]]: string;
};

export class IncomingDocument extends AbstractDocument {
	static meta: IncomingDocumentMeta;
	static NAMES: IncomingDocumentNames;
	meta: IncomingDocumentMeta;
	init(): void;
	"envelopeNumber": lang.ObservableProperty<string>;
	"incomingDate": lang.ObservableProperty<Date>;
	"deliveryOption": lang.ObservableProperty<DeliveryOption>;
	"referenceNumber": lang.ObservableProperty<string>;
	"referenceDate": lang.ObservableProperty<Date>;
	"correspondentExternal": lang.ObservableProperty<AbstractCorrespondent>;
	"signedByExternal": lang.ObservableProperty<string>;
	"registrator": lang.ObservableProperty<EmployeePosition>;
	"sheetsAmount": lang.ObservableProperty<number>;
	"annexSheetsAmount": lang.ObservableProperty<number>;
	"reviewDeadlineDate": lang.ObservableProperty<Date>;
	"addressees": lang.ObservableGetter<IDomainCollection<IncomingDocumentAddressee>>;
}

export interface EmployeePositionMeta extends metadata.EntityMeta {
	props: AbstractOrgStructureElementMeta["props"] & {
		"parent": metadata.PropertyMeta;
		"employee": metadata.PropertyMeta;
		"assistants": metadata.PropertyMeta;
		"displayName": metadata.PropertyMeta;
	};
	complex: AbstractOrgStructureElementMeta["complex"] ;
}
export type EmployeePositionNames = {
	readonly [P in keyof EmployeePositionMeta["props"] | keyof EmployeePositionMeta["complex"]]: string;
};

export class EmployeePosition extends AbstractOrgStructureElement {
	static meta: EmployeePositionMeta;
	static NAMES: EmployeePositionNames;
	meta: EmployeePositionMeta;
	init(): void;
	"parent": lang.ObservableProperty<Position>;
	"employee": lang.ObservableProperty<Employee>;
	"assistants": lang.ObservableGetter<IDomainCollection<Assistant>>;
	"displayName": lang.ObservableProperty<string>;
}

export interface PositionMeta extends metadata.EntityMeta {
	props: AbstractOrgStructureElementMeta["props"] & {
		"parent": metadata.PropertyMeta;
		"positionDescription": metadata.PropertyMeta;
		"employeePositions": metadata.PropertyMeta;
	};
	complex: AbstractOrgStructureElementMeta["complex"] ;
}
export type PositionNames = {
	readonly [P in keyof PositionMeta["props"] | keyof PositionMeta["complex"]]: string;
};

export class Position extends AbstractOrgStructureElement {
	static meta: PositionMeta;
	static NAMES: PositionNames;
	meta: PositionMeta;
	init(): void;
	"parent": lang.ObservableProperty<Department>;
	"positionDescription": lang.ObservableProperty<PositionDescription>;
	"employeePositions": lang.ObservableGetter<IDomainCollection<EmployeePosition>>;
}

export interface WarrantDocumentMeta extends metadata.EntityMeta {
	props: AbstractDocumentMeta["props"] & {
		"notarizationRequired": metadata.PropertyMeta;
		"performer": metadata.PropertyMeta;
		"registrator": metadata.PropertyMeta;
		"principal": metadata.PropertyMeta;
		"confidant": metadata.PropertyMeta;
		"startDate": metadata.PropertyMeta;
		"period": metadata.PropertyMeta;
		"sheetsAmount": metadata.PropertyMeta;
	};
	complex: AbstractDocumentMeta["complex"] ;
}
export type WarrantDocumentNames = {
	readonly [P in keyof WarrantDocumentMeta["props"] | keyof WarrantDocumentMeta["complex"]]: string;
};

export class WarrantDocument extends AbstractDocument {
	static meta: WarrantDocumentMeta;
	static NAMES: WarrantDocumentNames;
	meta: WarrantDocumentMeta;
	init(): void;
	"notarizationRequired": lang.ObservableProperty<boolean>;
	"performer": lang.ObservableProperty<EmployeePosition>;
	"registrator": lang.ObservableProperty<EmployeePosition>;
	"principal": lang.ObservableProperty<EmployeePosition>;
	"confidant": lang.ObservableProperty<EmployeePosition>;
	"startDate": lang.ObservableProperty<Date>;
	"period": lang.ObservableProperty<number>;
	"sheetsAmount": lang.ObservableProperty<number>;
}

export interface RoleDescriptorDefaultMeta extends metadata.EntityMeta {
	props: {
		"roleName": metadata.PropertyMeta;
		"description": metadata.PropertyMeta;
		"roleParams": metadata.PropertyMeta;
	};
}
export type RoleDescriptorDefaultNames = {
	readonly [P in keyof RoleDescriptorDefaultMeta["props"] | keyof RoleDescriptorDefaultMeta["complex"]]: string;
};

export class RoleDescriptorDefault extends DomainObject {
	static meta: RoleDescriptorDefaultMeta;
	static NAMES: RoleDescriptorDefaultNames;
	meta: RoleDescriptorDefaultMeta;
	init(): void;
	"roleName": lang.ObservableProperty<string>;
	"description": lang.ObservableProperty<string>;
	"roleParams": lang.ObservableGetter<IDomainCollection<RoleParamDescriptorDefault>>;
}

export interface RelationTypeMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"reverse": metadata.PropertyMeta;
		"sourceTypes": metadata.PropertyMeta;
		"targetTypes": metadata.PropertyMeta;
		"systemName": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type RelationTypeNames = {
	readonly [P in keyof RelationTypeMeta["props"] | keyof RelationTypeMeta["complex"]]: string;
};

export class RelationType extends DomainObject {
	static meta: RelationTypeMeta;
	static NAMES: RelationTypeNames;
	meta: RelationTypeMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"reverse": lang.ObservableProperty<RelationType>;
	"sourceTypes": lang.ObservableGetter<IDomainCollection<DocumentType>>;
	"targetTypes": lang.ObservableGetter<IDomainCollection<DocumentType>>;
	"systemName": lang.ObservableProperty<string>;
	"deleted": lang.ObservableProperty<boolean>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface CorrespondentFilterMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
	};
}
export type CorrespondentFilterNames = {
	readonly [P in keyof CorrespondentFilterMeta["props"] | keyof CorrespondentFilterMeta["complex"]]: string;
};

export class CorrespondentFilter extends DomainObject {
	static meta: CorrespondentFilterMeta;
	static NAMES: CorrespondentFilterNames;
	meta: CorrespondentFilterMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"deleted": lang.ObservableProperty<boolean>;
}

export interface CompanyCorrespondentMeta extends metadata.EntityMeta {
	props: AbstractCorrespondentMeta["props"] & {
		"shortName": metadata.PropertyMeta;
		"persons": metadata.PropertyMeta;
	};
	complex: AbstractCorrespondentMeta["complex"] ;
}
export type CompanyCorrespondentNames = {
	readonly [P in keyof CompanyCorrespondentMeta["props"] | keyof CompanyCorrespondentMeta["complex"]]: string;
};

export class CompanyCorrespondent extends AbstractCorrespondent {
	static meta: CompanyCorrespondentMeta;
	static NAMES: CompanyCorrespondentNames;
	meta: CompanyCorrespondentMeta;
	init(): void;
	"shortName": lang.ObservableProperty<string>;
	"persons": lang.ObservableGetter<IDomainCollection<CompanyPersonCorrespondent>>;
}

export interface ContractDocumentMeta extends metadata.EntityMeta {
	props: AbstractDocumentMeta["props"] & {
		"createdBasedOn": metadata.PropertyMeta;
		"urgent": metadata.PropertyMeta;
		"paper": metadata.PropertyMeta;
		"performer": metadata.PropertyMeta;
		"registrator": metadata.PropertyMeta;
		"signatory": metadata.PropertyMeta;
		"sheetsAmount": metadata.PropertyMeta;
		"annexSheetsAmount": metadata.PropertyMeta;
		"contractors": metadata.PropertyMeta;
		"preparedByContractor": metadata.PropertyMeta;
		"protocolDisagreements": metadata.PropertyMeta;
		"protocolApproveDisagreements": metadata.PropertyMeta;
		"cost": metadata.PropertyMeta;
		"currency": metadata.PropertyMeta;
		"costRub": metadata.PropertyMeta;
		"settlementType": metadata.PropertyMeta;
		"contractState": metadata.PropertyMeta;
		"agreementDate": metadata.PropertyMeta;
		"durationFromDate": metadata.PropertyMeta;
		"durationToDate": metadata.PropertyMeta;
		"completedDate": metadata.PropertyMeta;
		"conditionIntoForce": metadata.PropertyMeta;
		"determiningCost": metadata.PropertyMeta;
		"terminationDate": metadata.PropertyMeta;
		"terminationReason": metadata.PropertyMeta;
		"curator": metadata.PropertyMeta;
		"signingDate": metadata.PropertyMeta;
		"warrantName": metadata.PropertyMeta;
		"dealWithInterest": metadata.PropertyMeta;
		"bigDeal": metadata.PropertyMeta;
		"greatlyDeal": metadata.PropertyMeta;
		"officialRegistration": metadata.PropertyMeta;
		"propertyTransfer": metadata.PropertyMeta;
		"notes": metadata.PropertyMeta;
		"documentType": metadata.PropertyMeta;
		"summary": metadata.PropertyMeta;
	};
	complex: AbstractDocumentMeta["complex"] ;
}
export type ContractDocumentNames = {
	readonly [P in keyof ContractDocumentMeta["props"] | keyof ContractDocumentMeta["complex"]]: string;
};

export class ContractDocument extends AbstractDocument {
	static meta: ContractDocumentMeta;
	static NAMES: ContractDocumentNames;
	meta: ContractDocumentMeta;
	init(): void;
	"createdBasedOn": lang.ObservableProperty<DocumentTemplate>;
	"urgent": lang.ObservableProperty<boolean>;
	"paper": lang.ObservableProperty<boolean>;
	"performer": lang.ObservableProperty<EmployeePosition>;
	"registrator": lang.ObservableProperty<EmployeePosition>;
	"signatory": lang.ObservableProperty<EmployeePosition>;
	"sheetsAmount": lang.ObservableProperty<number>;
	"annexSheetsAmount": lang.ObservableProperty<number>;
	"contractors": lang.ObservableGetter<IDomainCollection<ContractDocumentContractor>>;
	"preparedByContractor": lang.ObservableProperty<boolean>;
	"protocolDisagreements": lang.ObservableProperty<boolean>;
	"protocolApproveDisagreements": lang.ObservableProperty<boolean>;
	"cost": lang.ObservableProperty<Big>;
	"currency": lang.ObservableProperty<Currency>;
	"costRub": lang.ObservableProperty<Big>;
	"settlementType": lang.ObservableProperty<ContractSettlementType>;
	"contractState": lang.ObservableProperty<ContractState>;
	"agreementDate": lang.ObservableProperty<Date>;
	"durationFromDate": lang.ObservableProperty<Date>;
	"durationToDate": lang.ObservableProperty<Date>;
	"completedDate": lang.ObservableProperty<Date>;
	"conditionIntoForce": lang.ObservableProperty<ContractConditionIntoForce>;
	"determiningCost": lang.ObservableProperty<string>;
	"terminationDate": lang.ObservableProperty<Date>;
	"terminationReason": lang.ObservableProperty<ContractRevokeReason>;
	"curator": lang.ObservableProperty<EmployeePosition>;
	"signingDate": lang.ObservableProperty<Date>;
	"warrantName": lang.ObservableProperty<string>;
	"dealWithInterest": lang.ObservableProperty<boolean>;
	"bigDeal": lang.ObservableProperty<boolean>;
	"greatlyDeal": lang.ObservableProperty<boolean>;
	"officialRegistration": lang.ObservableProperty<boolean>;
	"propertyTransfer": lang.ObservableProperty<boolean>;
	"notes": lang.ObservableProperty<string>;
	"documentType": lang.ObservableProperty<DocumentSubType>;
	"summary": lang.ObservableProperty<string>;
}

export interface DepartmentMeta extends metadata.EntityMeta {
	props: AbstractOrgStructureElementMeta["props"] & {
		"fullName": metadata.PropertyMeta;
		"code": metadata.PropertyMeta;
		"referenceNumber": metadata.PropertyMeta;
		"headOfUnit": metadata.PropertyMeta;
		"parent": metadata.PropertyMeta;
		"departments": metadata.PropertyMeta;
		"positions": metadata.PropertyMeta;
		"name": metadata.PropertyMeta;
	};
	complex: AbstractOrgStructureElementMeta["complex"] ;
}
export type DepartmentNames = {
	readonly [P in keyof DepartmentMeta["props"] | keyof DepartmentMeta["complex"]]: string;
};

export class Department extends AbstractOrgStructureElement {
	static meta: DepartmentMeta;
	static NAMES: DepartmentNames;
	meta: DepartmentMeta;
	init(): void;
	"fullName": lang.ObservableProperty<string>;
	"code": lang.ObservableProperty<string>;
	"referenceNumber": lang.ObservableProperty<string>;
	"headOfUnit": lang.ObservableProperty<EmployeePosition>;
	"parent": lang.ObservableProperty<Department>;
	"departments": lang.ObservableGetter<IDomainCollection<Department>>;
	"positions": lang.ObservableGetter<IDomainCollection<Position>>;
	"name": lang.ObservableProperty<string>;
}

export interface WeekBasedWorkingCalendarDayIntervalMeta extends metadata.EntityMeta {
	props: {
		"calendar": metadata.PropertyMeta;
		"dayOfWeekValue": metadata.PropertyMeta;
		"begin": metadata.PropertyMeta;
		"end": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type WeekBasedWorkingCalendarDayIntervalNames = {
	readonly [P in keyof WeekBasedWorkingCalendarDayIntervalMeta["props"] | keyof WeekBasedWorkingCalendarDayIntervalMeta["complex"]]: string;
};

export class WeekBasedWorkingCalendarDayInterval extends DomainObject {
	static meta: WeekBasedWorkingCalendarDayIntervalMeta;
	static NAMES: WeekBasedWorkingCalendarDayIntervalNames;
	meta: WeekBasedWorkingCalendarDayIntervalMeta;
	init(): void;
	"calendar": lang.ObservableProperty<WeekBasedWorkingCalendar>;
	"dayOfWeekValue": lang.ObservableProperty<WeekBasedWorkingTimeDayNames>;
	"begin": lang.ObservableProperty<Date>;
	"end": lang.ObservableProperty<Date>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface UserMeta extends metadata.EntityMeta {
	props: {
		"login": metadata.PropertyMeta;
		"password": metadata.PropertyMeta;
		"active": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
		"lastLogin": metadata.PropertyMeta;
		"employee": metadata.PropertyMeta;
	};
}
export type UserNames = {
	readonly [P in keyof UserMeta["props"] | keyof UserMeta["complex"]]: string;
};

export class User extends DomainObject {
	static meta: UserMeta;
	static NAMES: UserNames;
	meta: UserMeta;
	init(): void;
	"login": lang.ObservableProperty<string>;
	"password": lang.ObservableProperty<string>;
	"active": lang.ObservableProperty<boolean>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
	"lastLogin": lang.ObservableProperty<Date>;
	"employee": lang.ObservableProperty<Employee>;
}

export interface ContractorFilterMeta extends metadata.EntityMeta {
	props: {
		"searchString": metadata.PropertyMeta;
		"allowDeleted": metadata.PropertyMeta;
	};
}
export type ContractorFilterNames = {
	readonly [P in keyof ContractorFilterMeta["props"] | keyof ContractorFilterMeta["complex"]]: string;
};

export class ContractorFilter extends DomainObject {
	static meta: ContractorFilterMeta;
	static NAMES: ContractorFilterNames;
	meta: ContractorFilterMeta;
	init(): void;
	"searchString": lang.ObservableProperty<string>;
	"allowDeleted": lang.ObservableProperty<boolean>;
}

export interface CommissionPerformerReportAttachmentMeta extends metadata.EntityMeta {
	props: AttachmentMeta["props"] & {
		"aclId": metadata.PropertyMeta;
		"reports": metadata.PropertyMeta;
	};
	complex: AttachmentMeta["complex"] ;
}
export type CommissionPerformerReportAttachmentNames = {
	readonly [P in keyof CommissionPerformerReportAttachmentMeta["props"] | keyof CommissionPerformerReportAttachmentMeta["complex"]]: string;
};

export class CommissionPerformerReportAttachment extends Attachment {
	static meta: CommissionPerformerReportAttachmentMeta;
	static NAMES: CommissionPerformerReportAttachmentNames;
	meta: CommissionPerformerReportAttachmentMeta;
	init(): void;
	"aclId": lang.ObservableProperty<string>;
	"reports": lang.ObservableGetter<IDomainCollection<CommissionPerformerReport>>;
}

export interface AbstractReportParamsMeta extends metadata.EntityMeta {
	props: {
		"author": metadata.PropertyMeta;
		"taskId": metadata.PropertyMeta;
		"taskTypeId": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
	};
}
export type AbstractReportParamsNames = {
	readonly [P in keyof AbstractReportParamsMeta["props"] | keyof AbstractReportParamsMeta["complex"]]: string;
};

export class AbstractReportParams extends DomainObject {
	static meta: AbstractReportParamsMeta;
	static NAMES: AbstractReportParamsNames;
	meta: AbstractReportParamsMeta;
	init(): void;
	"author": lang.ObservableProperty<User>;
	"taskId": lang.ObservableProperty<string>;
	"taskTypeId": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
}

export interface CommissionStatusMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"systemName": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type CommissionStatusNames = {
	readonly [P in keyof CommissionStatusMeta["props"] | keyof CommissionStatusMeta["complex"]]: string;
};

export class CommissionStatus extends DomainObject {
	static meta: CommissionStatusMeta;
	static NAMES: CommissionStatusNames;
	meta: CommissionStatusMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"systemName": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface CmisContentMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"content": metadata.PropertyMeta;
	};
}
export type CmisContentNames = {
	readonly [P in keyof CmisContentMeta["props"] | keyof CmisContentMeta["complex"]]: string;
};

export class CmisContent extends DomainObject {
	static meta: CmisContentMeta;
	static NAMES: CmisContentNames;
	meta: CmisContentMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"content": lang.ObservableProperty<LobPropValue>;
}

export interface LockInfoCommandMeta extends metadata.EntityMeta {
	props: {
		"command": metadata.PropertyMeta;
		"lockedObjectId": metadata.PropertyMeta;
	};
}
export type LockInfoCommandNames = {
	readonly [P in keyof LockInfoCommandMeta["props"] | keyof LockInfoCommandMeta["complex"]]: string;
};

export class LockInfoCommand extends DomainObject {
	static meta: LockInfoCommandMeta;
	static NAMES: LockInfoCommandNames;
	meta: LockInfoCommandMeta;
	init(): void;
	"command": lang.ObservableProperty<string>;
	"lockedObjectId": lang.ObservableProperty<string>;
}

export interface NomenclatureCaseMeta extends metadata.EntityMeta {
	props: {
		"displayName": metadata.PropertyMeta;
		"index": metadata.PropertyMeta;
		"title": metadata.PropertyMeta;
		"year": metadata.PropertyMeta;
		"status": metadata.PropertyMeta;
		"retentionPeriod": metadata.PropertyMeta;
		"retentionPurpose": metadata.PropertyMeta;
		"retentionPolicy": metadata.PropertyMeta;
		"note": metadata.PropertyMeta;
		"openingDate": metadata.PropertyMeta;
		"closingDate": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type NomenclatureCaseNames = {
	readonly [P in keyof NomenclatureCaseMeta["props"] | keyof NomenclatureCaseMeta["complex"]]: string;
};

export class NomenclatureCase extends DomainObject {
	static meta: NomenclatureCaseMeta;
	static NAMES: NomenclatureCaseNames;
	meta: NomenclatureCaseMeta;
	init(): void;
	"displayName": lang.ObservableProperty<string>;
	"index": lang.ObservableProperty<string>;
	"title": lang.ObservableProperty<string>;
	"year": lang.ObservableProperty<NomenclatureYear>;
	"status": lang.ObservableProperty<NomenclatureStatus>;
	"retentionPeriod": lang.ObservableProperty<number>;
	"retentionPurpose": lang.ObservableProperty<string>;
	"retentionPolicy": lang.ObservableProperty<NomenclatureCaseRetentionPolicy>;
	"note": lang.ObservableProperty<string>;
	"openingDate": lang.ObservableProperty<Date>;
	"closingDate": lang.ObservableProperty<Date>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface DocumentTypeMeta extends metadata.EntityMeta {
	props: {
		"systemName": metadata.PropertyMeta;
		"parent": metadata.PropertyMeta;
		"name": metadata.PropertyMeta;
		"documentKinds": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
		"templateDocumentEntityName": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type DocumentTypeNames = {
	readonly [P in keyof DocumentTypeMeta["props"] | keyof DocumentTypeMeta["complex"]]: string;
};

export class DocumentType extends DomainObject {
	static meta: DocumentTypeMeta;
	static NAMES: DocumentTypeNames;
	meta: DocumentTypeMeta;
	init(): void;
	"systemName": lang.ObservableProperty<string>;
	"parent": lang.ObservableProperty<DocumentType>;
	"name": lang.ObservableProperty<string>;
	"documentKinds": lang.ObservableGetter<IDomainCollection<DocumentKind>>;
	"deleted": lang.ObservableProperty<boolean>;
	"templateDocumentEntityName": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface ContractDocumentJournalFilterMeta extends metadata.EntityMeta {
	props: {
		"organization": metadata.PropertyMeta;
		"contractor": metadata.PropertyMeta;
		"status": metadata.PropertyMeta;
		"contractState": metadata.PropertyMeta;
		"summary": metadata.PropertyMeta;
		"costFrom": metadata.PropertyMeta;
		"costTo": metadata.PropertyMeta;
		"creationDateFrom": metadata.PropertyMeta;
		"creationDateTo": metadata.PropertyMeta;
		"signingDateFrom": metadata.PropertyMeta;
		"signingDateTo": metadata.PropertyMeta;
		"performer": metadata.PropertyMeta;
		"curator": metadata.PropertyMeta;
		"signatory": metadata.PropertyMeta;
		"dealWithInterest": metadata.PropertyMeta;
		"bigDeal": metadata.PropertyMeta;
		"greatlyDeal": metadata.PropertyMeta;
	};
}
export type ContractDocumentJournalFilterNames = {
	readonly [P in keyof ContractDocumentJournalFilterMeta["props"] | keyof ContractDocumentJournalFilterMeta["complex"]]: string;
};

export class ContractDocumentJournalFilter extends DomainObject {
	static meta: ContractDocumentJournalFilterMeta;
	static NAMES: ContractDocumentJournalFilterNames;
	meta: ContractDocumentJournalFilterMeta;
	init(): void;
	"organization": lang.ObservableProperty<Company>;
	"contractor": lang.ObservableProperty<Contractor>;
	"status": lang.ObservableProperty<DocumentStatus>;
	"contractState": lang.ObservableProperty<ContractState>;
	"summary": lang.ObservableProperty<string>;
	"costFrom": lang.ObservableProperty<Big>;
	"costTo": lang.ObservableProperty<Big>;
	"creationDateFrom": lang.ObservableProperty<Date>;
	"creationDateTo": lang.ObservableProperty<Date>;
	"signingDateFrom": lang.ObservableProperty<Date>;
	"signingDateTo": lang.ObservableProperty<Date>;
	"performer": lang.ObservableProperty<EmployeePosition>;
	"curator": lang.ObservableProperty<EmployeePosition>;
	"signatory": lang.ObservableProperty<EmployeePosition>;
	"dealWithInterest": lang.ObservableProperty<boolean>;
	"bigDeal": lang.ObservableProperty<boolean>;
	"greatlyDeal": lang.ObservableProperty<boolean>;
}

export interface CorrespondentContactTypeMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"systemName": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type CorrespondentContactTypeNames = {
	readonly [P in keyof CorrespondentContactTypeMeta["props"] | keyof CorrespondentContactTypeMeta["complex"]]: string;
};

export class CorrespondentContactType extends DomainObject {
	static meta: CorrespondentContactTypeMeta;
	static NAMES: CorrespondentContactTypeNames;
	meta: CorrespondentContactTypeMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"systemName": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface WarrantJournalFilterMeta extends metadata.EntityMeta {
	props: {
		"regNumber": metadata.PropertyMeta;
		"identifier": metadata.PropertyMeta;
		"summary": metadata.PropertyMeta;
		"status": metadata.PropertyMeta;
		"startDate": metadata.PropertyMeta;
		"organization": metadata.PropertyMeta;
		"period": metadata.PropertyMeta;
	};
}
export type WarrantJournalFilterNames = {
	readonly [P in keyof WarrantJournalFilterMeta["props"] | keyof WarrantJournalFilterMeta["complex"]]: string;
};

export class WarrantJournalFilter extends DomainObject {
	static meta: WarrantJournalFilterMeta;
	static NAMES: WarrantJournalFilterNames;
	meta: WarrantJournalFilterMeta;
	init(): void;
	"regNumber": lang.ObservableProperty<string>;
	"identifier": lang.ObservableProperty<string>;
	"summary": lang.ObservableProperty<string>;
	"status": lang.ObservableProperty<DocumentStatus>;
	"startDate": lang.ObservableProperty<Date>;
	"organization": lang.ObservableProperty<Company>;
	"period": lang.ObservableProperty<number>;
}

export interface CommissionPerformerReportMeta extends metadata.EntityMeta {
	props: {
		"performer": metadata.PropertyMeta;
		"status": metadata.PropertyMeta;
		"reportVersion": metadata.PropertyMeta;
		"description": metadata.PropertyMeta;
		"author": metadata.PropertyMeta;
		"sent": metadata.PropertyMeta;
		"approved": metadata.PropertyMeta;
		"rejected": metadata.PropertyMeta;
		"rejectedBy": metadata.PropertyMeta;
		"reasonToReject": metadata.PropertyMeta;
		"aclId": metadata.PropertyMeta;
		"attachments": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type CommissionPerformerReportNames = {
	readonly [P in keyof CommissionPerformerReportMeta["props"] | keyof CommissionPerformerReportMeta["complex"]]: string;
};

export class CommissionPerformerReport extends DomainObject {
	static meta: CommissionPerformerReportMeta;
	static NAMES: CommissionPerformerReportNames;
	meta: CommissionPerformerReportMeta;
	init(): void;
	"performer": lang.ObservableProperty<CommissionPerformer>;
	"status": lang.ObservableProperty<CommissionPerformerReportStatus>;
	"reportVersion": lang.ObservableProperty<number>;
	"description": lang.ObservableProperty<string>;
	"author": lang.ObservableProperty<EmployeePosition>;
	"sent": lang.ObservableProperty<Date>;
	"approved": lang.ObservableProperty<Date>;
	"rejected": lang.ObservableProperty<Date>;
	"rejectedBy": lang.ObservableProperty<EmployeePosition>;
	"reasonToReject": lang.ObservableProperty<string>;
	"aclId": lang.ObservableProperty<string>;
	"attachments": lang.ObservableGetter<IDomainCollection<CommissionPerformerReportAttachment>>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface DocumentStatusMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"systemName": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type DocumentStatusNames = {
	readonly [P in keyof DocumentStatusMeta["props"] | keyof DocumentStatusMeta["complex"]]: string;
};

export class DocumentStatus extends DomainObject {
	static meta: DocumentStatusMeta;
	static NAMES: DocumentStatusNames;
	meta: DocumentStatusMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"systemName": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface ApprovalQueueMeta extends metadata.EntityMeta {
	props: {
		"owner": metadata.PropertyMeta;
		"iteration": metadata.PropertyMeta;
		"queueType": metadata.PropertyMeta;
		"createdOn": metadata.PropertyMeta;
		"editable": metadata.PropertyMeta;
		"name": metadata.PropertyMeta;
		"maxDays": metadata.PropertyMeta;
		"maxHours": metadata.PropertyMeta;
		"state": metadata.PropertyMeta;
		"aclId": metadata.PropertyMeta;
		"approvers": metadata.PropertyMeta;
	};
}
export type ApprovalQueueNames = {
	readonly [P in keyof ApprovalQueueMeta["props"] | keyof ApprovalQueueMeta["complex"]]: string;
};

export class ApprovalQueue extends DomainObject {
	static meta: ApprovalQueueMeta;
	static NAMES: ApprovalQueueNames;
	meta: ApprovalQueueMeta;
	init(): void;
	"owner": lang.ObservableProperty<Approver>;
	"iteration": lang.ObservableProperty<ApprovalIteration>;
	"queueType": lang.ObservableProperty<ApprovalQueueType>;
	"createdOn": lang.ObservableProperty<ApprovalPlanningStage>;
	"editable": lang.ObservableProperty<boolean>;
	"name": lang.ObservableProperty<string>;
	"maxDays": lang.ObservableProperty<number>;
	"maxHours": lang.ObservableProperty<number>;
	"state": lang.ObservableProperty<ApprovalEntityState>;
	"aclId": lang.ObservableProperty<string>;
	"approvers": lang.ObservableGetter<IDomainCollection<Approver>>;
}

export interface CorrespondentContactKindMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"contactTypes": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type CorrespondentContactKindNames = {
	readonly [P in keyof CorrespondentContactKindMeta["props"] | keyof CorrespondentContactKindMeta["complex"]]: string;
};

export class CorrespondentContactKind extends DomainObject {
	static meta: CorrespondentContactKindMeta;
	static NAMES: CorrespondentContactKindNames;
	meta: CorrespondentContactKindMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"contactTypes": lang.ObservableGetter<IDomainCollection<CorrespondentContactType>>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface AccessorsGroupMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"items": metadata.PropertyMeta;
	};
}
export type AccessorsGroupNames = {
	readonly [P in keyof AccessorsGroupMeta["props"] | keyof AccessorsGroupMeta["complex"]]: string;
};

export class AccessorsGroup extends DomainObject {
	static meta: AccessorsGroupMeta;
	static NAMES: AccessorsGroupNames;
	meta: AccessorsGroupMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"items": lang.ObservableGetter<IDomainCollection<AccessorsGroupItem>>;
}

export interface DocumentTemplateMeta extends metadata.EntityMeta {
	props: {
		"parent": metadata.PropertyMeta;
		"company": metadata.PropertyMeta;
		"name": metadata.PropertyMeta;
		"description": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
		"document": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type DocumentTemplateNames = {
	readonly [P in keyof DocumentTemplateMeta["props"] | keyof DocumentTemplateMeta["complex"]]: string;
};

export class DocumentTemplate extends DomainObject {
	static meta: DocumentTemplateMeta;
	static NAMES: DocumentTemplateNames;
	meta: DocumentTemplateMeta;
	init(): void;
	"parent": lang.ObservableProperty<DocumentSubType>;
	"company": lang.ObservableProperty<Company>;
	"name": lang.ObservableProperty<string>;
	"description": lang.ObservableProperty<string>;
	"deleted": lang.ObservableProperty<boolean>;
	"document": lang.ObservableProperty<AbstractDocument>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface RelationTypeFilterMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"sourceType": metadata.PropertyMeta;
		"deleted": metadata.PropertyMeta;
	};
}
export type RelationTypeFilterNames = {
	readonly [P in keyof RelationTypeFilterMeta["props"] | keyof RelationTypeFilterMeta["complex"]]: string;
};

export class RelationTypeFilter extends DomainObject {
	static meta: RelationTypeFilterMeta;
	static NAMES: RelationTypeFilterNames;
	meta: RelationTypeFilterMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"sourceType": lang.ObservableProperty<DocumentType>;
	"deleted": lang.ObservableProperty<boolean>;
}

export interface NomenclatureYearMeta extends metadata.EntityMeta {
	props: {
		"year": metadata.PropertyMeta;
		"department": metadata.PropertyMeta;
		"status": metadata.PropertyMeta;
		"cases": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type NomenclatureYearNames = {
	readonly [P in keyof NomenclatureYearMeta["props"] | keyof NomenclatureYearMeta["complex"]]: string;
};

export class NomenclatureYear extends DomainObject {
	static meta: NomenclatureYearMeta;
	static NAMES: NomenclatureYearNames;
	meta: NomenclatureYearMeta;
	init(): void;
	"year": lang.ObservableProperty<number>;
	"department": lang.ObservableProperty<Department>;
	"status": lang.ObservableProperty<NomenclatureStatus>;
	"cases": lang.ObservableGetter<IDomainCollection<NomenclatureCase>>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface WorkingCalendarDayIntervalObjectMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"calendarTypeId": metadata.PropertyMeta;
		"calendarId": metadata.PropertyMeta;
		"eventType": metadata.PropertyMeta;
		"allDayEvent": metadata.PropertyMeta;
		"begin": metadata.PropertyMeta;
		"end": metadata.PropertyMeta;
	};
}
export type WorkingCalendarDayIntervalObjectNames = {
	readonly [P in keyof WorkingCalendarDayIntervalObjectMeta["props"] | keyof WorkingCalendarDayIntervalObjectMeta["complex"]]: string;
};

export class WorkingCalendarDayIntervalObject extends DomainObject {
	static meta: WorkingCalendarDayIntervalObjectMeta;
	static NAMES: WorkingCalendarDayIntervalObjectNames;
	meta: WorkingCalendarDayIntervalObjectMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"calendarTypeId": lang.ObservableProperty<string>;
	"calendarId": lang.ObservableProperty<string>;
	"eventType": lang.ObservableProperty<string>;
	"allDayEvent": lang.ObservableProperty<boolean>;
	"begin": lang.ObservableProperty<Date>;
	"end": lang.ObservableProperty<Date>;
}

export interface IncomingDocumentJournalFilterMeta extends metadata.EntityMeta {
	props: {
		"regNumber": metadata.PropertyMeta;
		"identifier": metadata.PropertyMeta;
		"summary": metadata.PropertyMeta;
		"status": metadata.PropertyMeta;
		"regDateFrom": metadata.PropertyMeta;
		"regDateTo": metadata.PropertyMeta;
		"envelopeNumber": metadata.PropertyMeta;
		"referenceNumber": metadata.PropertyMeta;
		"correspondentExternal": metadata.PropertyMeta;
		"organization": metadata.PropertyMeta;
		"nomenclatureCase": metadata.PropertyMeta;
	};
}
export type IncomingDocumentJournalFilterNames = {
	readonly [P in keyof IncomingDocumentJournalFilterMeta["props"] | keyof IncomingDocumentJournalFilterMeta["complex"]]: string;
};

export class IncomingDocumentJournalFilter extends DomainObject {
	static meta: IncomingDocumentJournalFilterMeta;
	static NAMES: IncomingDocumentJournalFilterNames;
	meta: IncomingDocumentJournalFilterMeta;
	init(): void;
	"regNumber": lang.ObservableProperty<string>;
	"identifier": lang.ObservableProperty<string>;
	"summary": lang.ObservableProperty<string>;
	"status": lang.ObservableProperty<DocumentStatus>;
	"regDateFrom": lang.ObservableProperty<Date>;
	"regDateTo": lang.ObservableProperty<Date>;
	"envelopeNumber": lang.ObservableProperty<string>;
	"referenceNumber": lang.ObservableProperty<string>;
	"correspondentExternal": lang.ObservableProperty<AbstractCorrespondent>;
	"organization": lang.ObservableProperty<Company>;
	"nomenclatureCase": lang.ObservableProperty<NomenclatureCase>;
}

export interface OutgoingDocumentMeta extends metadata.EntityMeta {
	props: AbstractDocumentMeta["props"] & {
		"urgent": metadata.PropertyMeta;
		"paper": metadata.PropertyMeta;
		"performer": metadata.PropertyMeta;
		"registrator": metadata.PropertyMeta;
		"signatory": metadata.PropertyMeta;
		"sheetsAmount": metadata.PropertyMeta;
		"annexSheetsAmount": metadata.PropertyMeta;
		"addressees": metadata.PropertyMeta;
	};
	complex: AbstractDocumentMeta["complex"] ;
}
export type OutgoingDocumentNames = {
	readonly [P in keyof OutgoingDocumentMeta["props"] | keyof OutgoingDocumentMeta["complex"]]: string;
};

export class OutgoingDocument extends AbstractDocument {
	static meta: OutgoingDocumentMeta;
	static NAMES: OutgoingDocumentNames;
	meta: OutgoingDocumentMeta;
	init(): void;
	"urgent": lang.ObservableProperty<boolean>;
	"paper": lang.ObservableProperty<boolean>;
	"performer": lang.ObservableProperty<EmployeePosition>;
	"registrator": lang.ObservableProperty<EmployeePosition>;
	"signatory": lang.ObservableProperty<EmployeePosition>;
	"sheetsAmount": lang.ObservableProperty<number>;
	"annexSheetsAmount": lang.ObservableProperty<number>;
	"addressees": lang.ObservableGetter<IDomainCollection<OutgoingDocumentAddressee>>;
}

export interface DeliveryTypeMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"systemName": metadata.PropertyMeta;
		"creationTime": metadata.PropertyMeta;
		"lastModifiedTime": metadata.PropertyMeta;
	};
}
export type DeliveryTypeNames = {
	readonly [P in keyof DeliveryTypeMeta["props"] | keyof DeliveryTypeMeta["complex"]]: string;
};

export class DeliveryType extends DomainObject {
	static meta: DeliveryTypeMeta;
	static NAMES: DeliveryTypeNames;
	meta: DeliveryTypeMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"systemName": lang.ObservableProperty<string>;
	"creationTime": lang.ObservableProperty<Date>;
	"lastModifiedTime": lang.ObservableProperty<Date>;
}

export interface FiledInMeta extends metadata.EntityMeta {
	props: {
		"folderId": metadata.PropertyMeta;
		"objectId": metadata.PropertyMeta;
	};
}
export type FiledInNames = {
	readonly [P in keyof FiledInMeta["props"] | keyof FiledInMeta["complex"]]: string;
};

export class FiledIn extends DomainObject {
	static meta: FiledInMeta;
	static NAMES: FiledInNames;
	meta: FiledInMeta;
	init(): void;
	"folderId": lang.ObservableProperty<string>;
	"objectId": lang.ObservableProperty<string>;
}

export interface UserFilterMeta extends metadata.EntityMeta {
	props: {
		"login": metadata.PropertyMeta;
	};
}
export type UserFilterNames = {
	readonly [P in keyof UserFilterMeta["props"] | keyof UserFilterMeta["complex"]]: string;
};

export class UserFilter extends DomainObject {
	static meta: UserFilterMeta;
	static NAMES: UserFilterNames;
	meta: UserFilterMeta;
	init(): void;
	"login": lang.ObservableProperty<string>;
}

export interface EmployeeFilterMeta extends metadata.EntityMeta {
	props: {
		"searchString": metadata.PropertyMeta;
		"allowDeleted": metadata.PropertyMeta;
	};
}
export type EmployeeFilterNames = {
	readonly [P in keyof EmployeeFilterMeta["props"] | keyof EmployeeFilterMeta["complex"]]: string;
};

export class EmployeeFilter extends DomainObject {
	static meta: EmployeeFilterMeta;
	static NAMES: EmployeeFilterNames;
	meta: EmployeeFilterMeta;
	init(): void;
	"searchString": lang.ObservableProperty<string>;
	"allowDeleted": lang.ObservableProperty<boolean>;
}

export interface PositionDescriptionFilterMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"allowDeleted": metadata.PropertyMeta;
	};
}
export type PositionDescriptionFilterNames = {
	readonly [P in keyof PositionDescriptionFilterMeta["props"] | keyof PositionDescriptionFilterMeta["complex"]]: string;
};

export class PositionDescriptionFilter extends DomainObject {
	static meta: PositionDescriptionFilterMeta;
	static NAMES: PositionDescriptionFilterNames;
	meta: PositionDescriptionFilterMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"allowDeleted": lang.ObservableProperty<boolean>;
}

export interface OrgStructureFilterMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"allowDeleted": metadata.PropertyMeta;
	};
}
export type OrgStructureFilterNames = {
	readonly [P in keyof OrgStructureFilterMeta["props"] | keyof OrgStructureFilterMeta["complex"]]: string;
};

export class OrgStructureFilter extends DomainObject {
	static meta: OrgStructureFilterMeta;
	static NAMES: OrgStructureFilterNames;
	meta: OrgStructureFilterMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"allowDeleted": lang.ObservableProperty<boolean>;
}

export interface FakeEmptyTypeMeta extends metadata.EntityMeta {
}
export type FakeEmptyTypeNames = {
	readonly [P in keyof FakeEmptyTypeMeta["props"] | keyof FakeEmptyTypeMeta["complex"]]: string;
};

export class FakeEmptyType extends DomainObject {
	static meta: FakeEmptyTypeMeta;
	static NAMES: FakeEmptyTypeNames;
	meta: FakeEmptyTypeMeta;
	init(): void;
}

export interface WeekBasedWorkingCalendarFilterMeta extends metadata.EntityMeta {
	props: {
		"date": metadata.PropertyMeta;
		"intervalType": metadata.PropertyMeta;
	};
}
export type WeekBasedWorkingCalendarFilterNames = {
	readonly [P in keyof WeekBasedWorkingCalendarFilterMeta["props"] | keyof WeekBasedWorkingCalendarFilterMeta["complex"]]: string;
};

export class WeekBasedWorkingCalendarFilter extends DomainObject {
	static meta: WeekBasedWorkingCalendarFilterMeta;
	static NAMES: WeekBasedWorkingCalendarFilterNames;
	meta: WeekBasedWorkingCalendarFilterMeta;
	init(): void;
	"date": lang.ObservableProperty<Date>;
	"intervalType": lang.ObservableProperty<WeekBasedWorkingCalendarIntervalTypeNames>;
}

export interface CopyWeekBasedWorkingCalendarDateIntervalParamsMeta extends metadata.EntityMeta {
	props: {
		"year": metadata.PropertyMeta;
	};
}
export type CopyWeekBasedWorkingCalendarDateIntervalParamsNames = {
	readonly [P in keyof CopyWeekBasedWorkingCalendarDateIntervalParamsMeta["props"] | keyof CopyWeekBasedWorkingCalendarDateIntervalParamsMeta["complex"]]: string;
};

export class CopyWeekBasedWorkingCalendarDateIntervalParams extends DomainObject {
	static meta: CopyWeekBasedWorkingCalendarDateIntervalParamsMeta;
	static NAMES: CopyWeekBasedWorkingCalendarDateIntervalParamsNames;
	meta: CopyWeekBasedWorkingCalendarDateIntervalParamsMeta;
	init(): void;
	"year": lang.ObservableProperty<Date>;
}

export interface MainPageInboxFilterMeta extends metadata.EntityMeta {
	props: {
		"taskType": metadata.PropertyMeta;
		"isNew": metadata.PropertyMeta;
		"isExpiring": metadata.PropertyMeta;
		"isExpired": metadata.PropertyMeta;
		"urgent": metadata.PropertyMeta;
	};
}
export type MainPageInboxFilterNames = {
	readonly [P in keyof MainPageInboxFilterMeta["props"] | keyof MainPageInboxFilterMeta["complex"]]: string;
};

export class MainPageInboxFilter extends DomainObject {
	static meta: MainPageInboxFilterMeta;
	static NAMES: MainPageInboxFilterNames;
	meta: MainPageInboxFilterMeta;
	init(): void;
	"taskType": lang.ObservableProperty<MainPageInboxFilterTaskNames>;
	"isNew": lang.ObservableProperty<boolean>;
	"isExpiring": lang.ObservableProperty<boolean>;
	"isExpired": lang.ObservableProperty<boolean>;
	"urgent": lang.ObservableProperty<boolean>;
}

export interface ApprovalIterationFilterMeta extends metadata.EntityMeta {
	props: {
		"iteration": metadata.PropertyMeta;
	};
}
export type ApprovalIterationFilterNames = {
	readonly [P in keyof ApprovalIterationFilterMeta["props"] | keyof ApprovalIterationFilterMeta["complex"]]: string;
};

export class ApprovalIterationFilter extends DomainObject {
	static meta: ApprovalIterationFilterMeta;
	static NAMES: ApprovalIterationFilterNames;
	meta: ApprovalIterationFilterMeta;
	init(): void;
	"iteration": lang.ObservableProperty<ApprovalIteration>;
}

export interface NomenclatureTreeFilterModelMeta extends metadata.EntityMeta {
	props: {
		"company": metadata.PropertyMeta;
		"status": metadata.PropertyMeta;
	};
}
export type NomenclatureTreeFilterModelNames = {
	readonly [P in keyof NomenclatureTreeFilterModelMeta["props"] | keyof NomenclatureTreeFilterModelMeta["complex"]]: string;
};

export class NomenclatureTreeFilterModel extends DomainObject {
	static meta: NomenclatureTreeFilterModelMeta;
	static NAMES: NomenclatureTreeFilterModelNames;
	meta: NomenclatureTreeFilterModelMeta;
	init(): void;
	"company": lang.ObservableProperty<Company>;
	"status": lang.ObservableProperty<NomenclatureStatus>;
}

export interface ModelMeta extends metadata.ModelMeta {
	enums: {
		DocumentPermission: DocumentPermissionMeta;
		ContractState: ContractStateMeta;
		ContractConditionIntoForce: ContractConditionIntoForceMeta;
		BookmarkType: BookmarkTypeMeta;
		ContractSettlementType: ContractSettlementTypeMeta;
		ApprovalIterationState: ApprovalIterationStateMeta;
		ApprovalPlanningStage: ApprovalPlanningStageMeta;
		DocumentProcessType: DocumentProcessTypeMeta;
		NomenclatureStatus: NomenclatureStatusMeta;
		ApprovalQueueType: ApprovalQueueTypeMeta;
		IncomingDocumentAddresseeStatus: IncomingDocumentAddresseeStatusMeta;
		OutgoingDocumentDeliveryStatus: OutgoingDocumentDeliveryStatusMeta;
		SearchType: SearchTypeMeta;
		CommissionType: CommissionTypeMeta;
		ApprovalEntityState: ApprovalEntityStateMeta;
		ApprovalDecisionType: ApprovalDecisionTypeMeta;
		ReportGenerationStatus: ReportGenerationStatusMeta;
		NomenclatureCaseRetentionPolicy: NomenclatureCaseRetentionPolicyMeta;
		WeekBasedWorkingCalendarIntervalTypeNames: WeekBasedWorkingCalendarIntervalTypeNamesMeta;
		WeekBasedWorkingTimeDayNames: WeekBasedWorkingTimeDayNamesMeta;
		MainPageInboxFilterTaskNames: MainPageInboxFilterTaskNamesMeta;
	};
	complex: {
	};
	entities: {
		PersonCorrespondent: PersonCorrespondentMeta;
		CommissionJournalFilter: CommissionJournalFilterMeta;
		ContractRevokeReason: ContractRevokeReasonMeta;
		InboxFilter: InboxFilterMeta;
		Employee: EmployeeMeta;
		DeliveryOption: DeliveryOptionMeta;
		Rendition: RenditionMeta;
		IncomingDocumentAddressee: IncomingDocumentAddresseeMeta;
		SearchResultDocumentWithAttachments: SearchResultDocumentWithAttachmentsMeta;
		CurrencyFilter: CurrencyFilterMeta;
		DocumentSubType: DocumentSubTypeMeta;
		Dashboard: DashboardMeta;
		CreateDocumentProcessParams: CreateDocumentProcessParamsMeta;
		AbstractCorrespondent: AbstractCorrespondentMeta;
		DocumentTypeTreeFilter: DocumentTypeTreeFilterMeta;
		OrgStructureRootElement: OrgStructureRootElementMeta;
		InboxViewItem: InboxViewItemMeta;
		AbstractCorrespondentContact: AbstractCorrespondentContactMeta;
		ContractorCreationParams: ContractorCreationParamsMeta;
		OutgoingDocumentAddressee: OutgoingDocumentAddresseeMeta;
		Approver: ApproverMeta;
		ApprovalIteration: ApprovalIterationMeta;
		CompanyPersonCorrespondent: CompanyPersonCorrespondentMeta;
		Assistant: AssistantMeta;
		ContractRevokeReasonFilter: ContractRevokeReasonFilterMeta;
		Currency: CurrencyMeta;
		AbstractDocumentRelation: AbstractDocumentRelationMeta;
		Comment: CommentMeta;
		DisciplineReportParams: DisciplineReportParamsMeta;
		CommissionPerformerStatus: CommissionPerformerStatusMeta;
		Company: CompanyMeta;
		PositionDescription: PositionDescriptionMeta;
		DocumentAttachment: DocumentAttachmentMeta;
		CommissionPerformerReportStatus: CommissionPerformerReportStatusMeta;
		ContractDocumentContractor: ContractDocumentContractorMeta;
		DocumentProcessTypeFakeModel: DocumentProcessTypeFakeModelMeta;
		OutgoingDocumentJournalFilter: OutgoingDocumentJournalFilterMeta;
		AbstractDocument: AbstractDocumentMeta;
		LockInfoDefault: LockInfoDefaultMeta;
		TempContent: TempContentMeta;
		CommissionPerformer: CommissionPerformerMeta;
		WeekBasedWorkingCalendarDateInterval: WeekBasedWorkingCalendarDateIntervalMeta;
		CorrespondentAddress: CorrespondentAddressMeta;
		Commission: CommissionMeta;
		Bookmark: BookmarkMeta;
		ApprovalDecision: ApprovalDecisionMeta;
		AbstractOrgStructureElement: AbstractOrgStructureElementMeta;
		CorrespondentContactDefault: CorrespondentContactDefaultMeta;
		SmartSearchFilter: SmartSearchFilterMeta;
		WeekBasedWorkingCalendar: WeekBasedWorkingCalendarMeta;
		Report: ReportMeta;
		ReportContent: ReportContentMeta;
		Contractor: ContractorMeta;
		CommonTaskCommand: CommonTaskCommandMeta;
		TaskType: TaskTypeMeta;
		DocumentKind: DocumentKindMeta;
		AccessorsGroupItem: AccessorsGroupItemMeta;
		RegNumberTemplate: RegNumberTemplateMeta;
		DocumentToDocumentRelation: DocumentToDocumentRelationMeta;
		Attachment: AttachmentMeta;
		ReportGenerationTask: ReportGenerationTaskMeta;
		RegisterDocumentProcessParams: RegisterDocumentProcessParamsMeta;
		RoleParamDescriptorDefault: RoleParamDescriptorDefaultMeta;
		IncomingDocument: IncomingDocumentMeta;
		EmployeePosition: EmployeePositionMeta;
		Position: PositionMeta;
		WarrantDocument: WarrantDocumentMeta;
		RoleDescriptorDefault: RoleDescriptorDefaultMeta;
		RelationType: RelationTypeMeta;
		CorrespondentFilter: CorrespondentFilterMeta;
		CompanyCorrespondent: CompanyCorrespondentMeta;
		ContractDocument: ContractDocumentMeta;
		Department: DepartmentMeta;
		WeekBasedWorkingCalendarDayInterval: WeekBasedWorkingCalendarDayIntervalMeta;
		User: UserMeta;
		ContractorFilter: ContractorFilterMeta;
		CommissionPerformerReportAttachment: CommissionPerformerReportAttachmentMeta;
		AbstractReportParams: AbstractReportParamsMeta;
		CommissionStatus: CommissionStatusMeta;
		CmisContent: CmisContentMeta;
		LockInfoCommand: LockInfoCommandMeta;
		NomenclatureCase: NomenclatureCaseMeta;
		DocumentType: DocumentTypeMeta;
		ContractDocumentJournalFilter: ContractDocumentJournalFilterMeta;
		CorrespondentContactType: CorrespondentContactTypeMeta;
		WarrantJournalFilter: WarrantJournalFilterMeta;
		CommissionPerformerReport: CommissionPerformerReportMeta;
		DocumentStatus: DocumentStatusMeta;
		ApprovalQueue: ApprovalQueueMeta;
		CorrespondentContactKind: CorrespondentContactKindMeta;
		AccessorsGroup: AccessorsGroupMeta;
		DocumentTemplate: DocumentTemplateMeta;
		RelationTypeFilter: RelationTypeFilterMeta;
		NomenclatureYear: NomenclatureYearMeta;
		WorkingCalendarDayIntervalObject: WorkingCalendarDayIntervalObjectMeta;
		IncomingDocumentJournalFilter: IncomingDocumentJournalFilterMeta;
		OutgoingDocument: OutgoingDocumentMeta;
		DeliveryType: DeliveryTypeMeta;
		FiledIn: FiledInMeta;
		UserFilter: UserFilterMeta;
		EmployeeFilter: EmployeeFilterMeta;
		PositionDescriptionFilter: PositionDescriptionFilterMeta;
		OrgStructureFilter: OrgStructureFilterMeta;
		FakeEmptyType: FakeEmptyTypeMeta;
		WeekBasedWorkingCalendarFilter: WeekBasedWorkingCalendarFilterMeta;
		CopyWeekBasedWorkingCalendarDateIntervalParams: CopyWeekBasedWorkingCalendarDateIntervalParamsMeta;
		MainPageInboxFilter: MainPageInboxFilterMeta;
		ApprovalIterationFilter: ApprovalIterationFilterMeta;
		NomenclatureTreeFilterModel: NomenclatureTreeFilterModelMeta;
	};
}
export const meta: ModelMeta;
